<project SchemaVersion="1.3">
    <assemblies>
        <assembly location=".\bin\Debug\NunitWeb.dll" documentation=".\bin\Debug\NunitWeb.xml" />
    </assemblies>
    <namespaces>
      <namespace name="MonoTests.SystemWeb.Framework">
        <para>
          The idea of the Framework is as follows:
        </para>
        <para>
          A Web application root is created
          in a temp directory. All currently referenced and loaded assemblies are copied
          to the /bin folder. Starting from this point, <see cref="HttpRuntime.ProcessRequest()"/> is
          able to process any requests, compiling ASPX, themes, master pages, etc., if
          necessary.
        </para>
        <para>A few words about the API:</para>
        <para>
          <see cref="WebTest"/> is the central class of the Framework. Its instances are typically
          created in NUnit test cases. WebTest instances carry the information from the
          test case application domain into the Web application domain, and back. The most
          important properties of WebTest are <see cref="Request"/> and <see cref="Invoker"/>.
          The Request carries all
          the necessary information used to create an HttpWorkerRequest in the Web application domain.
          The Invoker carries all the callbacks that have to be invoked to perform the
          tests in the Web application domain. Here is an example of using WebTest, Request,
          and Invoker.
        </para>
        <example>
          <code>
            <![CDATA[
[Test]
public void TestCase1 ()
{
  WebTest t = new WebTest ();
  t.Invoker = PageInvoker.CreateOnLoad (TestCase1OnLoad));
  t.Request.Url = "MyPage.aspx";
  string htmlRes = t.Run();
  //HtmlDiff on htmlRes ...
}

static public void TestCase1OnLoad (Page p) //invoked in the web appdomain
{
  Assert.AreEqual ("White", p.StyleSheetTheme);
}]]>
          </code>
        </example>

        <para>There is support for postback. The flow goes like this:</para>
        <para>1. You make a first request like:</para>

        <example>
          <code>
            WebTest t = new WebTest ("SomePage.aspx");
            t.Run ();
          </code>
        </example>

        <para>2. Then you use the response to create a FormRequest:</para>

        <example>
          <code>
            FormRequest f = new FormRequest (t.Response);
          </code>
        </example>

        <para>
          This will parse the response, and use action URL, GET/POST methods and all
          hidden fields (VIEWSTATE, etc.). You might add more query parameters, like:
        </para>
        <example>
          <code>
            f.Controls.Add (new BaseControl ("button1", ""));
            f.Controls.Add (new BaseControl ("textbox1", "some text");
          </code>
        </example>

        <para>3. Then run the second request:</para>

        <example>
          <code>
            t.Request = f;
            t.Run ();
          </code>
        </example>

        <para>
          It can be useful to install some callbacks for the second request, before
          calling to t.Run(), as in the following:
        </para>
        
        <example>
          <code>
            t.Invoker = PageInvoker.CreateOnLoad (MyDelegate);
          </code>
        </example>

        <para>The delegate for the above test may look like:</para>

        <example>
          <code>
            <![CDATA[
t.Invoker = PageInvoker.CreateOnLoad (MyDelegate);

static public void MyDelegate (Page p)
{
  Assert.IsTrue (p.IsPostBack);
  Assert.AreEqual ("some text", ((TextControl)p.FindControl ("textbox1")).Text);
}]]>
          </code>
        </example>


      </namespace>
    </namespaces>
    <documenters>
        <documenter name="JavaDoc">
            <property name="OutputDirectory" value=".\doc\" />
            <property name="SkipNamespacesWithoutSummaries" value="True" />
        </documenter>
        <documenter name="LaTeX">
            <property name="OutputDirectory" value=".\doc\" />
            <property name="TextFileFullName" value="Documentation.tex" />
            <property name="TexFileBaseName" value="Documentation" />
            <property name="LatexCompiler" value="latex" />
            <property name="TexFileFullPath" value=".\doc\Documentation.tex" />
        </documenter>
        <documenter name="LinearHtml">
            <property name="OutputDirectory" value=".\doc\" />
            <property name="Title" value="Web Hosting Test Framework" />
            <property name="IncludeHierarchy" value="True" />
            <property name="CopyrightText" value="Andrew Skiba &lt;andrews@mainsoft.com&gt;" />
            <property name="FeedbackEmailAddress" value="andrews@mainsoft.com" />
        </documenter>
        <documenter name="MSDN">
            <property name="OutputDirectory" value=".\doc\" />
            <property name="HtmlHelpName" value="NunitWeb" />
            <property name="Title" value="Web Hosting Test Framework" />
            <property name="SkipNamespacesWithoutSummaries" value="True" />
            <property name="CopyrightText" value="Andrew Skiba &lt;andrews@mainsoft.com&gt;" />
            <property name="FeedbackEmailAddress" value="andrews@mainsoft.com" />
        </documenter>
        <documenter name="MSDN 2003">
            <property name="OutputDirectory" value=".\doc\" />
            <property name="Title" value="An NDoc Documented Class Library" />
        </documenter>
        <documenter name="VS.NET 2003">
            <property name="OutputDirectory" value=".\doc\" />
            <property name="HtmlHelpName" value="Documentation" />
            <property name="Title" value="An NDoc documented library" />
        </documenter>
        <documenter name="XML">
            <property name="OutputFile" value=".\doc\doc.xml" />
        </documenter>
    </documenters>
</project>