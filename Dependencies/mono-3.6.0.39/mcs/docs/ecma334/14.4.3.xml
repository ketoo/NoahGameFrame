<?xml version="1.0"?>
<clause number="14.4.3" title="Function member invocation">
  <paragraph>This section describes the process that takes place at run-time to invoke a particular function member. It is assumed that a compile-time process has already determined the particular member to invoke, possibly by applying overload resolution to a set of candidate function members. </paragraph>
  <paragraph>For purposes of describing the invocation process, function members are divided into two categories: <list><list_item> Static function members. These are static methods, instance constructors, static property accessors, and user-defined operators. Static function members are always non-virtual. </list_item><list_item> Instance function members. These are instance methods, instance property accessors, and indexer accessors. Instance function members are either non-virtual or virtual, and are always invoked on a particular instance. The instance is computed by an instance expression, and it becomes accessible within the function member as this (<hyperlink>14.5.7</hyperlink>). </list_item></list></paragraph>
  <paragraph>The run-time processing of a function member invocation consists of the following steps, where M is the function member and, if M is an instance member, E is the instance expression: <list><list_item> If M is a static function member: </list_item><list><list_item> The argument list is evaluated as described in <hyperlink>14.4.1</hyperlink>. </list_item><list_item> M is invoked. </list_item></list><list_item> If M is an instance function member declared in a value-type: </list_item><list><list_item> E is evaluated. If this evaluation causes an exception, then no further steps are executed. </list_item><list_item> If E is not classified as a variable, then a temporary local variable of E's type is created and the value of E is assigned to that variable. E is then reclassified as a reference to that temporary local variable. The temporary variable is accessible as this within M, but not in any other way. Thus, only when E is a true variable is it possible for the caller to observe the changes that M makes to this. </list_item><list_item> The argument list is evaluated as described in <hyperlink>14.4.1</hyperlink>. </list_item><list_item> M is invoked. The variable referenced by E becomes the variable referenced by this. </list_item></list><list_item> If M is an instance function member declared in a reference-type: </list_item><list><list_item> E is evaluated. If this evaluation causes an exception, then no further steps are executed. </list_item><list_item> The argument list is evaluated as described in <hyperlink>14.4.1</hyperlink>. </list_item><list_item> If the type of E is a <non_terminal where="11.1">value-type</non_terminal>, a boxing conversion (<hyperlink>11.3.1</hyperlink>) is performed to convert E to type object, and E is considered to be of type object in the following steps. <note>[Note: In this case, M could only be a member of System.Object. end note]</note> </list_item><list_item> The value of E is checked to be valid. If the value of E is null, a System.NullReferenceException is thrown and no further steps are executed. </list_item><list_item> The function member implementation to invoke is determined: </list_item><list><list_item> If the compile-time type of E is an interface, the function member to invoke is the implementation of M provided by the run-time type of the instance referenced by E. This function member is determined by applying the interface mapping rules (<hyperlink>20.4.2</hyperlink>) to determine the implementation of M provided by the run-time type of the instance referenced by E. </list_item><list_item> Otherwise, if M is a virtual function member, the function member to invoke is the implementation of M provided by the run-time type of the instance referenced by E. This function member is determined by applying the rules for determining the most derived implementation (<hyperlink>17.5.3</hyperlink>) of M with respect to the run-time type of the instance referenced by E. </list_item><list_item> Otherwise, M is a non-virtual function member, and the function member to invoke is M itself. </list_item></list><list_item> The function member implementation determined in the step above is invoked. The object referenced by E becomes the object referenced by this. </list_item></list></list></paragraph>
</clause>
