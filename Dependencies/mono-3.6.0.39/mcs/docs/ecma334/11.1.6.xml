<?xml version="1.0"?>
<clause number="11.1.6" title="The decimal type">
  <paragraph>The <keyword>decimal</keyword> type is a 128-bit data type suitable for financial and monetary calculations. The <keyword>decimal</keyword> type can represent values ranging from 1.0 <unicode>215</unicode> 10<super>-28</super> to approximately 7.9 <unicode>215</unicode> 10<super>28</super> with 28-29 significant digits. </paragraph>
  <paragraph>The finite set of values of type <keyword>decimal</keyword> are of the form -1<super>s</super> <unicode>215</unicode> c <unicode>215</unicode> 10<super>-e</super>, where the sign s is 0 or 1, the coefficient c is given by 0 <unicode>8804</unicode> c &lt; 2<super>96</super>, and the scale e is such that 0 <unicode>8804</unicode> e <unicode>8804</unicode> 28. The <keyword>decimal</keyword> type does not support signed zeros, infinities, or NaN's. </paragraph>
  <paragraph>A <keyword>decimal</keyword> is represented as a 96-bit integer scaled by a power of ten. For decimals with an absolute value less than 1.0m, the value is exact to the 28<super>th</super> <keyword>decimal</keyword> place, but no further. For decimals with an absolute value greater than or equal to 1.0m, the value is exact to 28 or 29 digits. Contrary to the <keyword>float</keyword> and <keyword>double</keyword> data types, <keyword>decimal</keyword> fractional numbers such as 0.1 can be represented exactly in the <keyword>decimal</keyword> representation. In the <keyword>float</keyword> and <keyword>double</keyword> representations, such numbers are often infinite fractions, making those representations more prone to round-off errors. </paragraph>
  <paragraph>If one of the operands of a binary operator is of type <keyword>decimal</keyword>, then the other operand must be of an integral type or of type <keyword>decimal</keyword>. If an integral type operand is present, it is converted to <keyword>decimal</keyword> before the operation is performed. </paragraph>
  <paragraph>The result of an operation on values of type <keyword>decimal</keyword> is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation. Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as &quot;banker's rounding&quot;). That is, results are exact to 28 or 29 digits, but to no more than 28 <keyword>decimal</keyword> places. A zero result always has a sign of 0 and a scale of 0. </paragraph>
  <paragraph>If a <keyword>decimal</keyword> arithmetic operation produces a value that is too small for the <keyword>decimal</keyword> format after rounding, the result of the operation becomes zero. If a <keyword>decimal</keyword> arithmetic operation produces a result that is too large for the <keyword>decimal</keyword> format, a System.OverflowException is thrown. </paragraph>
  <paragraph>The <keyword>decimal</keyword> type has greater precision but smaller range than the floating-point types. Thus, conversions from the floating-point types to <keyword>decimal</keyword> might produce overflow exceptions, and conversions from <keyword>decimal</keyword> to the floating-point types might cause loss of precision. For these reasons, no implicit conversions exist between the floating-point types and <keyword>decimal</keyword>, and without explicit casts, it is not possible to mix floating-point and <keyword>decimal</keyword> operands in the same expression. </paragraph>
</clause>
