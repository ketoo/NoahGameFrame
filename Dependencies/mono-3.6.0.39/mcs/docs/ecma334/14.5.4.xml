<?xml version="1.0"?>
<clause number="14.5.4" title="Member access">
  <paragraph>A <non_terminal where="14.5.4">member-access</non_terminal> consists of a <non_terminal where="14.5">primary-expression</non_terminal> or a <non_terminal where="14.5.4">predefined-type</non_terminal>, followed by a &quot;.&quot; token, followed by an identifier. <grammar_production><name><non_terminal where="14.5.4">member-access</non_terminal></name> : <rhs><non_terminal where="14.5">primary-expression</non_terminal><terminal>.</terminal><non_terminal where="9.4.2">identifier</non_terminal></rhs><rhs><non_terminal where="14.5.4">predefined-type</non_terminal><terminal>.</terminal><non_terminal where="9.4.2">identifier</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="14.5.4">predefined-type</non_terminal></name> : one of <rhs><keyword>bool</keyword><keyword>byte</keyword><keyword>char</keyword><keyword>decimal</keyword><keyword>double</keyword><keyword>float</keyword><keyword>int</keyword><keyword>long</keyword></rhs><rhs><keyword>object</keyword><keyword>sbyte</keyword><keyword>short</keyword><keyword>string</keyword><keyword>uint</keyword><keyword>ulong</keyword><keyword>ushort</keyword></rhs></grammar_production></paragraph>
  <paragraph>A <non_terminal where="14.5.4">member-access</non_terminal> of the form E.I, where E is a <non_terminal where="14.5">primary-expression</non_terminal> or a <non_terminal where="14.5.4">predefined-type</non_terminal> and I is an identifier, is evaluated and classified as follows: <list><list_item> If E is a namespace and I is the name of an accessible member of that namespace, then the result is that member and, depending on the member, is classified as a namespace or a type. </list_item><list_item> If E is a <non_terminal where="14.5.4">predefined-type</non_terminal> or a <non_terminal where="14.5">primary-expression</non_terminal> classified as a type, and a member lookup (<hyperlink>14.3</hyperlink>) of I in E produces a match, then E.I is evaluated and classified as follows: </list_item><list><list_item> If I identifies a type, then the result is that type. </list_item><list_item> If I identifies one or more methods, then the result is a method group with no associated instance expression. </list_item><list_item> If I identifies a static property, then the result is a property access with no associated instance expression. </list_item><list_item> If I identifies a static field: </list_item><list><list_item> If the field is readonly and the reference occurs outside the static constructor of the class or struct in which the field is declared, then the result is a value, namely the value of the static field I in E. </list_item><list_item> Otherwise, the result is a variable, namely the static field I in E. </list_item></list><list_item> If I identifies a static event: </list_item><list><list_item> If the reference occurs within the class or struct in which the event is declared, and the event was declared without <non_terminal where="17.7">event-accessor-declarations</non_terminal> (<hyperlink>17.7</hyperlink>), then E.I is processed exactly as if I was a static field. </list_item><list_item> Otherwise, the result is an event access with no associated instance expression. </list_item></list><list_item> If I identifies a constant, then the result is a value, namely the value of that constant. </list_item><list_item> If I identifies an enumeration member, then the result is a value, namely the value of that enumeration member. </list_item><list_item> Otherwise, E.I is an invalid member reference, and a compile-time error occurs. </list_item></list><list_item> If E is a property access, indexer access, variable, or value, the type of which is T, and a member lookup (<hyperlink>14.3</hyperlink>) of I in T produces a match, then E.I is evaluated and classified as follows: </list_item><list><list_item> First, if E is a property or indexer access, then the value of the property or indexer access is obtained (<hyperlink>14.1.1</hyperlink>) and E is reclassified as a value. </list_item><list_item> If I identifies one or more methods, then the result is a method group with an associated instance expression of E. </list_item><list_item> If I identifies an instance property, then the result is a property access with an associated instance expression of E. </list_item><list_item> If T is a <non_terminal where="11.2">class-type</non_terminal> and I identifies an instance field of that class-type: </list_item><list><list_item> If the value of E is null, then a System.NullReferenceException is thrown. </list_item><list_item> Otherwise, if the field is readonly and the reference occurs outside an instance constructor of the class in which the field is declared, then the result is a value, namely the value of the field I in the object referenced by E. </list_item><list_item> Otherwise, the result is a variable, namely the field I in the object referenced by E. </list_item></list><list_item> If T is a <non_terminal where="11.1">struct-type</non_terminal> and I identifies an instance field of that struct-type: </list_item><list><list_item> If E is a value, or if the field is readonly and the reference occurs outside an instance constructor of the struct in which the field is declared, then the result is a value, namely the value of the field I in the struct instance given by E. </list_item><list_item> Otherwise, the result is a variable, namely the field I in the struct instance given by E. </list_item></list><list_item> If I identifies an instance event: </list_item><list><list_item> If the reference occurs within the class or struct in which the event is declared, and the event was declared without <non_terminal where="17.7">event-accessor-declarations</non_terminal> (<hyperlink>17.7</hyperlink>), then E.I is processed exactly as if I was an instance field. </list_item><list_item> Otherwise, the result is an event access with an associated instance expression of E. </list_item></list></list><list_item> Otherwise, E.I is an invalid member reference, and a compile-time error occurs. </list_item></list></paragraph>
</clause>
