<?xml version="1.0"?>
<clause number="17.9" title="Operators">
  <paragraph>An operator is a member that defines the meaning of an expression operator that can be applied to instances of the class. Operators are declared using operator-declarations: <grammar_production><name><non_terminal where="17.9">operator-declaration</non_terminal></name> : <rhs><non_terminal where="24.2">attributes</non_terminal><opt/><non_terminal where="17.9">operator-modifiers</non_terminal><non_terminal where="17.9">operator-declarator</non_terminal><non_terminal where="17.9">operator-body</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">operator-modifier</non_terminal>s</name> : <rhs><non_terminal where="17.9">operator-modifier</non_terminal></rhs><rhs><non_terminal where="17.9">operator-modifiers</non_terminal><non_terminal where="17.9">operator-modifier</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">operator-modifier</non_terminal></name> : <rhs><keyword>public</keyword></rhs><rhs><keyword>static</keyword></rhs><rhs><keyword>extern</keyword></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">operator-declarator</non_terminal></name> : <rhs><non_terminal where="17.9">unary-operator-declarator</non_terminal></rhs><rhs><non_terminal where="17.9">binary-operator-declarator</non_terminal></rhs><rhs><non_terminal where="17.9">conversion-operator-declarator</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">unary-operator-declarator</non_terminal></name> : <rhs><non_terminal where="11">type</non_terminal><keyword>operator</keyword><non_terminal where="17.9">overloadable-unary-operator</non_terminal><terminal>(</terminal><non_terminal where="11">type</non_terminal><non_terminal where="9.4.2">identifier</non_terminal><terminal>)</terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">overloadable-unary-operator</non_terminal></name> : one of <rhs><terminal>+</terminal><terminal>-</terminal><terminal>!</terminal><terminal>~</terminal><terminal>++</terminal><terminal>--</terminal><keyword>true</keyword><keyword>false</keyword></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">binary-operator-declarator</non_terminal></name> : <rhs><non_terminal where="11">type</non_terminal><keyword>operator</keyword><non_terminal where="17.9">overloadable-binary-operator</non_terminal><terminal>(</terminal><non_terminal where="11">type</non_terminal><non_terminal where="9.4.2">identifier</non_terminal><terminal>,</terminal><non_terminal where="11">type</non_terminal><non_terminal where="9.4.2">identifier</non_terminal><terminal>)</terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">overloadable-binary-operator</non_terminal></name> : one of <rhs><terminal>+</terminal><terminal>-</terminal><terminal>*</terminal><terminal>/</terminal><terminal>%</terminal><terminal>&amp;</terminal><terminal>|</terminal><terminal>^</terminal><terminal>&lt;&lt;</terminal><terminal>&gt;&gt;</terminal><terminal>==</terminal><terminal>!=</terminal><terminal>&gt;</terminal><terminal>&lt;</terminal><terminal>&gt;=</terminal><terminal>&lt;=</terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">conversion-operator-declarator</non_terminal></name> :  <rhs><keyword>implicit</keyword><keyword>operator</keyword><non_terminal where="11">type</non_terminal><terminal>(</terminal><non_terminal where="11">type</non_terminal><non_terminal where="9.4.2">identifier</non_terminal><terminal>)</terminal></rhs><rhs><keyword>explicit</keyword><keyword>operator</keyword><non_terminal where="11">type</non_terminal><terminal>(</terminal><non_terminal where="11">type</non_terminal><non_terminal where="9.4.2">identifier</non_terminal><terminal>)</terminal></rhs></grammar_production><grammar_production><name><non_terminal where="17.9">operator-body</non_terminal></name> : <rhs><non_terminal where="15.2">block</non_terminal></rhs><rhs><terminal>;</terminal></rhs></grammar_production></paragraph>
  <paragraph>There are three categories of overloadable operators: Unary operators (<hyperlink>17.9.1</hyperlink>), binary operators (<hyperlink>17.9.2</hyperlink>), and conversion operators (<hyperlink>17.9.3</hyperlink>). </paragraph>
  <paragraph>When an operator declaration includes an extern modifier, the operator is said to be an external operator. Because an external operator provides no actual implementation, its <non_terminal where="17.9">operator-body</non_terminal> consists of a semi-colon. For all other operators, the <non_terminal where="17.9">operator-body</non_terminal> consists of a block, which specifies the statements to execute when the operator is invoked. The block of an operator must conform to the rules for value-returning methods described in <hyperlink>17.5.8</hyperlink>. </paragraph>
  <paragraph>The following rules apply to all operator declarations: <list><list_item> An operator declaration must include both a public and a static modifier. </list_item><list_item> The parameter(s) of an operator must be value parameters. It is a compile-time error for an operator declaration to specify ref or out parameters. </list_item><list_item> The signature of an operator (<hyperlink>17.9.1</hyperlink>, <hyperlink>17.9.2</hyperlink>, <hyperlink>17.9.3</hyperlink>) must differ from the signatures of all other operators declared in the same class. </list_item><list_item> All types referenced in an operator declaration must be at least as accessible as the operator itself (<hyperlink>10.5.4</hyperlink>). </list_item><list_item> It is an error for the same modifier to appear multiple times in an operator declaration. </list_item></list></paragraph>
  <paragraph>Each operator category imposes additional restrictions, as described in the following sections. </paragraph>
  <paragraph>Like other members, operators declared in a base class are inherited by derived classes. Because operator declarations always require the class or struct in which the operator is declared to participate in the signature of the operator, it is not possible for an operator declared in a derived class to hide an operator declared in a base class. Thus, the new modifier is never required, and therefore never permitted, in an operator declaration. </paragraph>
  <paragraph>Additional information on unary and binary operators can be found in <hyperlink>14.2</hyperlink>. </paragraph>
  <paragraph>Additional information on conversion operators can be found in <hyperlink>13.4</hyperlink>. </paragraph>
</clause>
