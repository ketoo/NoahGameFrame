<?xml version="1.0"?>
<clause number="9.4.4.5" title="String literals">C# supports two forms of string literals: regular string literals and verbatim string literals. A regular string literal consists of zero or more characters enclosed in <keyword>double</keyword> quotes, as in &quot;hello, world&quot;, and may include both simple escape sequences (such as \t for the tab character), and hexadecimal and Unicode escape sequences. <paragraph>A verbatim string literal consists of an @ character followed by a double-quote character, zero or more </paragraph><paragraph>characters, and a closing double-quote character. <example>[Example: A simple example is @&quot;hello, world&quot;. end example]</example> In a verbatim string literal, the characters between the delimiters are interpreted verbatim, with the only exception being a <non_terminal where="9.4.4.5">quote-escape-sequence</non_terminal>. In particular, simple escape sequences, and hexadecimal and Unicode escape sequences are not processed in verbatim string literals. A verbatim string literal may span multiple lines. <grammar_production><name><non_terminal where="9.4.4.5">string-literal</non_terminal></name> :: <rhs><non_terminal where="9.4.4.5">regular-string-literal</non_terminal></rhs><rhs><non_terminal where="9.4.4.5">verbatim-string-literal</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">regular-string-literal</non_terminal></name> :: <rhs><terminal>&quot;</terminal><non_terminal where="9.4.4.5">regular-string-literal-characters</non_terminal><opt/><terminal>&quot;</terminal></rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">regular-string-literal-character</non_terminal>s</name> :: <rhs><non_terminal where="9.4.4.5">regular-string-literal-character</non_terminal></rhs><rhs><non_terminal where="9.4.4.5">regular-string-literal-characters</non_terminal><non_terminal where="9.4.4.5">regular-string-literal-character</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">regular-string-literal-character</non_terminal></name> :: <rhs><non_terminal where="9.4.4.5">single-regular-string-literal-character</non_terminal></rhs><rhs><non_terminal where="9.4.4.4">simple-escape-sequence</non_terminal></rhs><rhs><non_terminal where="9.4.4.4">hexadecimal-escape-sequence</non_terminal></rhs><rhs><non_terminal where="9.4.1">unicode-escape-sequence</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">single-regular-string-literal-character</non_terminal></name> :: <rhs>Any character except &quot; (U+0022), \ (U+005C), and <non_terminal where="9.3.2">new-line-character</non_terminal> </rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">verbatim-string-literal</non_terminal></name> :: <rhs><terminal>@&quot;</terminal><non_terminal where="9.4.4.5">verbatim-string-literal-characters</non_terminal><opt/><terminal>&quot;</terminal></rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">verbatim-string-literal-character</non_terminal>s</name> :: <rhs><non_terminal where="9.4.4.5">verbatim-string-literal-character</non_terminal></rhs><rhs><non_terminal where="9.4.4.5">verbatim-string-literal-characters</non_terminal><non_terminal where="9.4.4.5">verbatim-string-literal-character</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">verbatim-string-literal-character</non_terminal></name> :: <rhs><non_terminal where="9.4.4.5">single-verbatim-string-literal-character</non_terminal></rhs><rhs><non_terminal where="9.4.4.5">quote-escape-sequence</non_terminal></rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">single-verbatim-string-literal-character</non_terminal></name> :: <rhs>Any character except &quot; </rhs></grammar_production><grammar_production><name><non_terminal where="9.4.4.5">quote-escape-sequence</non_terminal></name> :: <rhs><terminal>&quot;&quot;</terminal></rhs></grammar_production></paragraph><paragraph><note>[Note: A character that follows a backslash character (\) in a <non_terminal where="9.4.4.5">regular-string-literal-character</non_terminal> must be one of the following characters: ', &quot;, \, 0, a, b, f, n, r, t, u, U, x, v. Otherwise, a compile-time error occurs. end note]</note></paragraph><paragraph><example>[Example: The example <code_example><![CDATA[
string a = "Happy birthday, Joel";      // Happy birthday, Joel  
string b = @"Happy birthday, Joel";     // Happy birthday, Joel  
string c = "hello \t world";          // hello    world  
string d = @"hello \t world";         // hello \t world  
string e = "Joe said \"Hello\" to me";   // Joe said "Hello" to me  
string f = @"Joe said ""Hello"" to me";  // Joe said "Hello" to me  
string g = "\\\\server\\share\\file.txt"; // \\server\share\file.txt  
string h = @"\\server\share\file.txt";   // \\server\share\file.txt  
string i = "one\r\ntwo\r\nthree";  
string j = @"one  
two  
three";  
]]></code_example>shows a variety of string literals. The last string literal, j, is a verbatim string literal that spans multiple lines. The characters between the quotation marks, including white space such as new line characters, are preserved verbatim. end example]</example></paragraph><paragraph><note>[Note: Since a hexadecimal escape sequence can have a variable number of hex digits, the string literal &quot;\x123&quot; contains a single character with hex value 123. To create a string containing the character with hex value 12 followed by the character 3, one could write &quot;\x00123&quot; or &quot;\x12&quot; + &quot;3&quot; instead. end note]</note></paragraph><paragraph>The type of a <non_terminal where="9.4.4.5">string-literal</non_terminal> is string. </paragraph><paragraph>Each string literal does not necessarily result in a new string instance. When two or more string literals that are equivalent according to the string equality operator (<hyperlink>14.9.7</hyperlink>), appear in the same assembly, these string literals refer to the same string instance. <example>[Example: For instance, the output produced by <code_example><![CDATA[
class Test  
{  
   static void Main() {  
      object a = "hello";  
      object b = "hello";  
      System.Console.WriteLine(a == b);  
   }  
}  
]]></code_example>is True because the two literals refer to the same string instance. end example]</example> </paragraph></clause>
