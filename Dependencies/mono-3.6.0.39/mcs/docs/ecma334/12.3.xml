<?xml version="1.0"?>
<clause number="12.3" title="Definite assignment">
  <paragraph>At a given location in the executable code of a function member, a variable is said to be definitely assigned if the compiler can prove, by static flow analysis, that the variable has been automatically initialized or has been the target of at least one assignment. The rules of definite assignment are: <list><list_item> An initially assigned variable (<hyperlink>12.3.1</hyperlink>) is always considered definitely assigned. </list_item><list_item> An initially unassigned variable (<hyperlink>12.3.2</hyperlink>) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following: </list_item><list><list_item> A simple assignment (<hyperlink>14.13.1</hyperlink>) in which the variable is the left operand. </list_item><list_item> An invocation expression (<hyperlink>14.5.5</hyperlink>) or object creation expression (<hyperlink>14.5.10.1</hyperlink>) that passes the variable as an output parameter. </list_item><list_item> For a local variable, a local variable declaration (<hyperlink>15.5</hyperlink>) that includes a variable initializer. </list_item></list></list></paragraph>
  <paragraph>The definite assignment states of instance variables of a <non_terminal where="11.1">struct-type</non_terminal> variable are tracked individually as well as collectively. In additional to the rules above, the following rules apply to <non_terminal where="11.1">struct-type</non_terminal> variables and their instance variables: <list><list_item> An instance variable is considered definitely assigned if its containing <non_terminal where="11.1">struct-type</non_terminal> variable is considered definitely assigned. </list_item><list_item> A <non_terminal where="11.1">struct-type</non_terminal> variable is considered definitely assigned if each of its instance variables is considered definitely assigned. </list_item></list></paragraph>
  <paragraph>Definite assignment is a requirement in the following contexts: <list><list_item> A variable must be definitely assigned at each location where its value is obtained. <note>[Note: This ensures that undefined values never occur. end note]</note> The occurrence of a variable in an expression is considered to obtain the value of the variable, except when </list_item><list><list_item> the variable is the left operand of a simple assignment, </list_item><list_item> the variable is passed as an output parameter, or </list_item><list_item> the variable is a <non_terminal where="11.1">struct-type</non_terminal> variable and occurs as the left operand of a member access. </list_item></list><list_item> A variable must be definitely assigned at each location where it is passed as a reference parameter. </list_item></list></paragraph>
  <paragraph>
    <note>[Note: This ensures that the function member being invoked can consider the reference parameter initially assigned. end note]</note>
    <list>
      <list_item> All output parameters of a function member must be definitely assigned at each location where the function member returns (through a return statement or through execution reaching the end of the function member body). <note>[Note: This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable. end note]</note> </list_item>
      <list_item> The this variable of a <non_terminal where="11.1">struct-type</non_terminal> instance constructor must be definitely assigned at each location where that instance constructor returns. </list_item>
    </list>
  </paragraph>
</clause>
