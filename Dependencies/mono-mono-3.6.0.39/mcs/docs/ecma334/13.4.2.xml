<?xml version="1.0"?>
<clause number="13.4.2" title="Evaluation of user-defined conversions">
  <paragraph>A user-defined conversion converts a value from its type, called the source type, to another type, called the target type. Evaluation of a user-defined conversion centers on finding the most specific user-defined conversion operator for the particular source and target types. This determination is broken into several steps: <list><list_item> Finding the set of classes and structs from which user-defined conversion operators will be considered. This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes). </list_item><list_item> From that set of types, determining which user-defined conversion operators are applicable. For a conversion operator to be applicable, it must be possible to perform a standard conversion (<hyperlink>13.3</hyperlink>) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type. </list_item><list_item> From the set of applicable user-defined operators, determining which operator is unambiguously the most specific. In general terms, the most specific operator is the operator whose operand type is &quot;closest&quot; to the source type and whose result type is &quot;closest&quot; to the target type. The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections. </list_item></list></paragraph>
  <paragraph>Once a most specific user-defined conversion operator has been identified, the actual execution of the  user-defined conversion involves up to three steps: <list><list_item> First, if required, performing a standard conversion from the source type to the operand type of the  user-defined conversion operator. </list_item><list_item> Next, invoking the user-defined conversion operator to perform the conversion. </list_item><list_item> Finally, if required, performing a standard conversion from the result type of the user-defined conversion operator to the target type. </list_item></list></paragraph>
  <paragraph>Evaluation of a user-defined conversion never involves more than one user-defined conversion operator. In other words, a conversion from type S to type T will never first execute a user-defined conversion from S to X and then execute a user-defined conversion from X to T. </paragraph>
  <paragraph>Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections. The definitions make use of the following terms: <list><list_item> If a standard implicit conversion (<hyperlink>13.3.1</hyperlink>) exists from a type A to a type B, and if neither A nor B are <non_terminal where="11.2">interface-type</non_terminal>s, then A is said to be encompassed by B, and B is said to encompass A. </list_item><list_item> The most encompassing type in a set of types is the one type that encompasses all other types in the set. If no single type encompasses all other types, then the set has no most encompassing type. In more intuitive terms, the most encompassing type is the &quot;largest&quot; type in the set-the one type to which each of the other types can be implicitly converted. </list_item><list_item> The most encompassed type in a set of types is the one type that is encompassed by all other types in the set. If no single type is encompassed by all other types, then the set has no most encompassed type. In more intuitive terms, the most encompassed type is the &quot;smallest&quot; type in the set-the one type that can be implicitly converted to each of the other types. </list_item></list></paragraph>
</clause>
