<?xml version="1.0"?>
<clause number="14.3" title="Member lookup">
  <paragraph>A member lookup is the process whereby the meaning of a name in the context of a type is determined. A member lookup may occur as part of evaluating a <non_terminal where="14.5.2">simple-name</non_terminal> (<hyperlink>14.5.2</hyperlink>) or a <non_terminal where="14.5.4">member-access</non_terminal> (<hyperlink>14.5.4</hyperlink>) in an expression. </paragraph>
  <paragraph>A member lookup of a name N in a type T is processed as follows: <list><list_item> First, the set of all accessible (<hyperlink>10.5</hyperlink>) members named N declared in T and the base types (<hyperlink>14.3.1</hyperlink>) of T is constructed. Declarations that include an override modifier are excluded from the set. If no members named N exist and are accessible, then the lookup produces no match, and the following steps are not evaluated. </list_item><list_item> Next, members that are hidden by other members are removed from the set. For every member S.M in the set, where S is the type in which the member M is declared, the following rules are applied: </list_item><list><list_item> If M is a constant, field, property, event, type, or enumeration member, then all members declared in a base type of S are removed from the set. </list_item><list_item> If M is a method, then all non-method members declared in a base type of S are removed from the set, and all methods with the same signature as M declared in a base type of S are removed from the set. </list_item></list><list_item> Finally, having removed hidden members, the result of the lookup is determined: </list_item><list><list_item> If the set consists of a single non-method member, then this member is the result of the lookup. </list_item><list_item> Otherwise, if the set contains only methods, then this group of methods is the result of the lookup. </list_item><list_item> Otherwise, the lookup is ambiguous, and a compile-time error occurs (this situation can only occur for a member lookup in an interface that has multiple direct base interfaces). </list_item></list></list></paragraph>
  <paragraph>For member lookups in types other than interfaces, and member lookups in interfaces that are strictly  single-inheritance (each interface in the inheritance chain has exactly zero or one direct base interface), the effect of the lookup rules is simply that derived members hide base members with the same name or signature. Such single-inheritance lookups are never ambiguous. The ambiguities that can possibly arise from member lookups in multiple-inheritance interfaces are described in <hyperlink>20.2.5</hyperlink>. </paragraph>
</clause>
