<?xml version="1.0"?>
<clause number="14.5.8" title="Base access">
  <paragraph>A <non_terminal where="14.5.8">base-access</non_terminal> consists of the reserved word base followed by either a &quot;.&quot; token and an identifier or an <non_terminal where="14.5.6">expression-list</non_terminal> enclosed in square brackets: <grammar_production><name><non_terminal where="14.5.8">base-access</non_terminal></name> : <rhs><keyword>base</keyword><terminal>.</terminal><non_terminal where="9.4.2">identifier</non_terminal></rhs><rhs><keyword>base</keyword><terminal>[</terminal><non_terminal where="14.5.6">expression-list</non_terminal><terminal>]</terminal></rhs></grammar_production></paragraph>
  <paragraph>A <non_terminal where="14.5.8">base-access</non_terminal> is used to access base class members that are hidden by similarly named members in the current class or struct. A <non_terminal where="14.5.8">base-access</non_terminal> is permitted only in the block of an instance constructor, an instance method, or an instance accessor. When base.I occurs in a class or struct, I must denote a member of the base class of that class or struct. Likewise, when base[E] occurs in a class, an applicable indexer must exist in the base class. </paragraph>
  <paragraph>At compile-time, <non_terminal where="14.5.8">base-access</non_terminal> expressions of the form base.I and base[E] are evaluated exactly as if they were written ((B)this).I and ((B)this)[E], where B is the base class of the class or struct in which the construct occurs. Thus, base.I and base[E] correspond to this.I and this[E], except this is viewed as an instance of the base class. </paragraph>
  <paragraph>When a <non_terminal where="14.5.8">base-access</non_terminal> references a virtual function member (a method, property, or indexer), the determination of which function member to invoke at run-time (<hyperlink>14.4.3</hyperlink>) is changed. The function member that is invoked is determined by finding the most derived implementation (<hyperlink>17.5.3</hyperlink>) of the function member with respect to B (instead of with respect to the run-time type of this, as would be usual in a non-base access). Thus, within an override of a virtual function member, a <non_terminal where="14.5.8">base-access</non_terminal> can be used to invoke the inherited implementation of the function member. If the function member referenced by a <non_terminal where="14.5.8">base-access</non_terminal> is abstract, a compile-time error occurs. </paragraph>
</clause>
