// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NFFleetingDefine.proto

#ifndef PROTOBUF_NFFleetingDefine_2eproto__INCLUDED
#define PROTOBUF_NFFleetingDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace NFFS {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_NFFleetingDefine_2eproto();
void protobuf_AssignDesc_NFFleetingDefine_2eproto();
void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

class FSVector3;
class SuwayyahEvents;
class SuwayyahEvents_Suwayyah;
class BulletEvents;
class BulletEvents_TacheBomp;
class BulletEvents_Bullet;
class AnimatorMoves;
class AnimatorMoves_Move;
class CameraControlEvents;
class CameraControlEvents_Camera;
class ParticleEvents;
class ParticleEvents_Particle;
class EnableEvents;
class EnableEvents_Enable;

enum SuwayyahEvents_ESEType {
  SuwayyahEvents_ESEType_ESET_SINGLE = 0,
  SuwayyahEvents_ESEType_ESET_SINGLE_AREA = 1,
  SuwayyahEvents_ESEType_ESET_LEFT_AREA = 2,
  SuwayyahEvents_ESEType_ESET_RIGHT_AREA = 3
};
bool SuwayyahEvents_ESEType_IsValid(int value);
const SuwayyahEvents_ESEType SuwayyahEvents_ESEType_ESEType_MIN = SuwayyahEvents_ESEType_ESET_SINGLE;
const SuwayyahEvents_ESEType SuwayyahEvents_ESEType_ESEType_MAX = SuwayyahEvents_ESEType_ESET_RIGHT_AREA;
const int SuwayyahEvents_ESEType_ESEType_ARRAYSIZE = SuwayyahEvents_ESEType_ESEType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SuwayyahEvents_ESEType_descriptor();
inline const ::std::string& SuwayyahEvents_ESEType_Name(SuwayyahEvents_ESEType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SuwayyahEvents_ESEType_descriptor(), value);
}
inline bool SuwayyahEvents_ESEType_Parse(
    const ::std::string& name, SuwayyahEvents_ESEType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SuwayyahEvents_ESEType>(
    SuwayyahEvents_ESEType_descriptor(), name, value);
}
enum BulletEvents_EBEType {
  BulletEvents_EBEType_ESET_TARGET = 0,
  BulletEvents_EBEType_ESET_POSITION = 1
};
bool BulletEvents_EBEType_IsValid(int value);
const BulletEvents_EBEType BulletEvents_EBEType_EBEType_MIN = BulletEvents_EBEType_ESET_TARGET;
const BulletEvents_EBEType BulletEvents_EBEType_EBEType_MAX = BulletEvents_EBEType_ESET_POSITION;
const int BulletEvents_EBEType_EBEType_ARRAYSIZE = BulletEvents_EBEType_EBEType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BulletEvents_EBEType_descriptor();
inline const ::std::string& BulletEvents_EBEType_Name(BulletEvents_EBEType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BulletEvents_EBEType_descriptor(), value);
}
inline bool BulletEvents_EBEType_Parse(
    const ::std::string& name, BulletEvents_EBEType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BulletEvents_EBEType>(
    BulletEvents_EBEType_descriptor(), name, value);
}
enum BulletEvents_EBE_BACKType {
  BulletEvents_EBE_BACKType_EBEBT_BACK = 0,
  BulletEvents_EBE_BACKType_EBEBT_SIDE = 1
};
bool BulletEvents_EBE_BACKType_IsValid(int value);
const BulletEvents_EBE_BACKType BulletEvents_EBE_BACKType_EBE_BACKType_MIN = BulletEvents_EBE_BACKType_EBEBT_BACK;
const BulletEvents_EBE_BACKType BulletEvents_EBE_BACKType_EBE_BACKType_MAX = BulletEvents_EBE_BACKType_EBEBT_SIDE;
const int BulletEvents_EBE_BACKType_EBE_BACKType_ARRAYSIZE = BulletEvents_EBE_BACKType_EBE_BACKType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BulletEvents_EBE_BACKType_descriptor();
inline const ::std::string& BulletEvents_EBE_BACKType_Name(BulletEvents_EBE_BACKType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BulletEvents_EBE_BACKType_descriptor(), value);
}
inline bool BulletEvents_EBE_BACKType_Parse(
    const ::std::string& name, BulletEvents_EBE_BACKType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BulletEvents_EBE_BACKType>(
    BulletEvents_EBE_BACKType_descriptor(), name, value);
}
enum AnimatorMoves_EAMType {
  AnimatorMoves_EAMType_EAMT_FORWARD = 0,
  AnimatorMoves_EAMType_EAMT_BACK = 1,
  AnimatorMoves_EAMType_EAMT_LEFT = 2,
  AnimatorMoves_EAMType_EAMT_RIGHT = 3
};
bool AnimatorMoves_EAMType_IsValid(int value);
const AnimatorMoves_EAMType AnimatorMoves_EAMType_EAMType_MIN = AnimatorMoves_EAMType_EAMT_FORWARD;
const AnimatorMoves_EAMType AnimatorMoves_EAMType_EAMType_MAX = AnimatorMoves_EAMType_EAMT_RIGHT;
const int AnimatorMoves_EAMType_EAMType_ARRAYSIZE = AnimatorMoves_EAMType_EAMType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AnimatorMoves_EAMType_descriptor();
inline const ::std::string& AnimatorMoves_EAMType_Name(AnimatorMoves_EAMType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AnimatorMoves_EAMType_descriptor(), value);
}
inline bool AnimatorMoves_EAMType_Parse(
    const ::std::string& name, AnimatorMoves_EAMType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimatorMoves_EAMType>(
    AnimatorMoves_EAMType_descriptor(), name, value);
}
enum CameraControlEvents_ECEType {
  CameraControlEvents_ECEType_Earthquake = 0,
  CameraControlEvents_ECEType_Explosion = 1,
  CameraControlEvents_ECEType_No = 2,
  CameraControlEvents_ECEType_FireKick = 3,
  CameraControlEvents_ECEType_Stomp = 4,
  CameraControlEvents_ECEType_Yes = 5,
  CameraControlEvents_ECEType_SprintShake = 6,
  CameraControlEvents_ECEType_FreeMode = 7,
  CameraControlEvents_ECEType_MainRPGMode = 8
};
bool CameraControlEvents_ECEType_IsValid(int value);
const CameraControlEvents_ECEType CameraControlEvents_ECEType_ECEType_MIN = CameraControlEvents_ECEType_Earthquake;
const CameraControlEvents_ECEType CameraControlEvents_ECEType_ECEType_MAX = CameraControlEvents_ECEType_MainRPGMode;
const int CameraControlEvents_ECEType_ECEType_ARRAYSIZE = CameraControlEvents_ECEType_ECEType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CameraControlEvents_ECEType_descriptor();
inline const ::std::string& CameraControlEvents_ECEType_Name(CameraControlEvents_ECEType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraControlEvents_ECEType_descriptor(), value);
}
inline bool CameraControlEvents_ECEType_Parse(
    const ::std::string& name, CameraControlEvents_ECEType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraControlEvents_ECEType>(
    CameraControlEvents_ECEType_descriptor(), name, value);
}
enum ParticleEvents_EPERTYPE {
  ParticleEvents_EPERTYPE_NONE = 0,
  ParticleEvents_EPERTYPE_MatchTarget = 1,
  ParticleEvents_EPERTYPE_Random_X = 2,
  ParticleEvents_EPERTYPE_Random_Y = 3,
  ParticleEvents_EPERTYPE_Random_Z = 4,
  ParticleEvents_EPERTYPE_Random_XY = 5,
  ParticleEvents_EPERTYPE_Random_XZ = 6,
  ParticleEvents_EPERTYPE_Random_YZ = 7,
  ParticleEvents_EPERTYPE_Random_XYZ = 8
};
bool ParticleEvents_EPERTYPE_IsValid(int value);
const ParticleEvents_EPERTYPE ParticleEvents_EPERTYPE_EPERTYPE_MIN = ParticleEvents_EPERTYPE_NONE;
const ParticleEvents_EPERTYPE ParticleEvents_EPERTYPE_EPERTYPE_MAX = ParticleEvents_EPERTYPE_Random_XYZ;
const int ParticleEvents_EPERTYPE_EPERTYPE_ARRAYSIZE = ParticleEvents_EPERTYPE_EPERTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParticleEvents_EPERTYPE_descriptor();
inline const ::std::string& ParticleEvents_EPERTYPE_Name(ParticleEvents_EPERTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParticleEvents_EPERTYPE_descriptor(), value);
}
inline bool ParticleEvents_EPERTYPE_Parse(
    const ::std::string& name, ParticleEvents_EPERTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParticleEvents_EPERTYPE>(
    ParticleEvents_EPERTYPE_descriptor(), name, value);
}
enum EnableEvents_EEETYPE {
  EnableEvents_EEETYPE_INIT = 0,
  EnableEvents_EEETYPE_FINAL = 1
};
bool EnableEvents_EEETYPE_IsValid(int value);
const EnableEvents_EEETYPE EnableEvents_EEETYPE_EEETYPE_MIN = EnableEvents_EEETYPE_INIT;
const EnableEvents_EEETYPE EnableEvents_EEETYPE_EEETYPE_MAX = EnableEvents_EEETYPE_FINAL;
const int EnableEvents_EEETYPE_EEETYPE_ARRAYSIZE = EnableEvents_EEETYPE_EEETYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnableEvents_EEETYPE_descriptor();
inline const ::std::string& EnableEvents_EEETYPE_Name(EnableEvents_EEETYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnableEvents_EEETYPE_descriptor(), value);
}
inline bool EnableEvents_EEETYPE_Parse(
    const ::std::string& name, EnableEvents_EEETYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnableEvents_EEETYPE>(
    EnableEvents_EEETYPE_descriptor(), name, value);
}
// ===================================================================

class FSVector3 : public ::google::protobuf::Message {
 public:
  FSVector3();
  virtual ~FSVector3();

  FSVector3(const FSVector3& from);

  inline FSVector3& operator=(const FSVector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FSVector3& default_instance();

  void Swap(FSVector3* other);

  // implements Message ----------------------------------------------

  FSVector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FSVector3& from);
  void MergeFrom(const FSVector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:NFFS.FSVector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static FSVector3* default_instance_;
};
// -------------------------------------------------------------------

class SuwayyahEvents_Suwayyah : public ::google::protobuf::Message {
 public:
  SuwayyahEvents_Suwayyah();
  virtual ~SuwayyahEvents_Suwayyah();

  SuwayyahEvents_Suwayyah(const SuwayyahEvents_Suwayyah& from);

  inline SuwayyahEvents_Suwayyah& operator=(const SuwayyahEvents_Suwayyah& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SuwayyahEvents_Suwayyah& default_instance();

  void Swap(SuwayyahEvents_Suwayyah* other);

  // implements Message ----------------------------------------------

  SuwayyahEvents_Suwayyah* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SuwayyahEvents_Suwayyah& from);
  void MergeFrom(const SuwayyahEvents_Suwayyah& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NFFS.SuwayyahEvents.ESEType EventType = 1;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  inline ::NFFS::SuwayyahEvents_ESEType eventtype() const;
  inline void set_eventtype(::NFFS::SuwayyahEvents_ESEType value);

  // required float EventTime = 2;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 2;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required float EndTime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 3;
  inline float endtime() const;
  inline void set_endtime(float value);

  // required float DamageRang = 4;
  inline bool has_damagerang() const;
  inline void clear_damagerang();
  static const int kDamageRangFieldNumber = 4;
  inline float damagerang() const;
  inline void set_damagerang(float value);

  // required float BackHeroDis = 5;
  inline bool has_backherodis() const;
  inline void clear_backherodis();
  static const int kBackHeroDisFieldNumber = 5;
  inline float backherodis() const;
  inline void set_backherodis(float value);

  // required float BackNpcDis = 6;
  inline bool has_backnpcdis() const;
  inline void clear_backnpcdis();
  static const int kBackNpcDisFieldNumber = 6;
  inline float backnpcdis() const;
  inline void set_backnpcdis(float value);

  // required string BeAttackParticle = 7;
  inline bool has_beattackparticle() const;
  inline void clear_beattackparticle();
  static const int kBeAttackParticleFieldNumber = 7;
  inline const ::std::string& beattackparticle() const;
  inline void set_beattackparticle(const ::std::string& value);
  inline void set_beattackparticle(const char* value);
  inline void set_beattackparticle(const char* value, size_t size);
  inline ::std::string* mutable_beattackparticle();
  inline ::std::string* release_beattackparticle();
  inline void set_allocated_beattackparticle(::std::string* beattackparticle);

  // required string MethodCall = 8;
  inline bool has_methodcall() const;
  inline void clear_methodcall();
  static const int kMethodCallFieldNumber = 8;
  inline const ::std::string& methodcall() const;
  inline void set_methodcall(const ::std::string& value);
  inline void set_methodcall(const char* value);
  inline void set_methodcall(const char* value, size_t size);
  inline ::std::string* mutable_methodcall();
  inline ::std::string* release_methodcall();
  inline void set_allocated_methodcall(::std::string* methodcall);

  // required string MethodParam = 9;
  inline bool has_methodparam() const;
  inline void clear_methodparam();
  static const int kMethodParamFieldNumber = 9;
  inline const ::std::string& methodparam() const;
  inline void set_methodparam(const ::std::string& value);
  inline void set_methodparam(const char* value);
  inline void set_methodparam(const char* value, size_t size);
  inline ::std::string* mutable_methodparam();
  inline ::std::string* release_methodparam();
  inline void set_allocated_methodparam(::std::string* methodparam);

  // required string TargetMethodCall = 10;
  inline bool has_targetmethodcall() const;
  inline void clear_targetmethodcall();
  static const int kTargetMethodCallFieldNumber = 10;
  inline const ::std::string& targetmethodcall() const;
  inline void set_targetmethodcall(const ::std::string& value);
  inline void set_targetmethodcall(const char* value);
  inline void set_targetmethodcall(const char* value, size_t size);
  inline ::std::string* mutable_targetmethodcall();
  inline ::std::string* release_targetmethodcall();
  inline void set_allocated_targetmethodcall(::std::string* targetmethodcall);

  // required string TargetMethodParam = 11;
  inline bool has_targetmethodparam() const;
  inline void clear_targetmethodparam();
  static const int kTargetMethodParamFieldNumber = 11;
  inline const ::std::string& targetmethodparam() const;
  inline void set_targetmethodparam(const ::std::string& value);
  inline void set_targetmethodparam(const char* value);
  inline void set_targetmethodparam(const char* value, size_t size);
  inline ::std::string* mutable_targetmethodparam();
  inline ::std::string* release_targetmethodparam();
  inline void set_allocated_targetmethodparam(::std::string* targetmethodparam);

  // @@protoc_insertion_point(class_scope:NFFS.SuwayyahEvents.Suwayyah)
 private:
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_damagerang();
  inline void clear_has_damagerang();
  inline void set_has_backherodis();
  inline void clear_has_backherodis();
  inline void set_has_backnpcdis();
  inline void clear_has_backnpcdis();
  inline void set_has_beattackparticle();
  inline void clear_has_beattackparticle();
  inline void set_has_methodcall();
  inline void clear_has_methodcall();
  inline void set_has_methodparam();
  inline void clear_has_methodparam();
  inline void set_has_targetmethodcall();
  inline void clear_has_targetmethodcall();
  inline void set_has_targetmethodparam();
  inline void clear_has_targetmethodparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int eventtype_;
  float eventtime_;
  float endtime_;
  float damagerang_;
  float backherodis_;
  float backnpcdis_;
  ::std::string* beattackparticle_;
  ::std::string* methodcall_;
  ::std::string* methodparam_;
  ::std::string* targetmethodcall_;
  ::std::string* targetmethodparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static SuwayyahEvents_Suwayyah* default_instance_;
};
// -------------------------------------------------------------------

class SuwayyahEvents : public ::google::protobuf::Message {
 public:
  SuwayyahEvents();
  virtual ~SuwayyahEvents();

  SuwayyahEvents(const SuwayyahEvents& from);

  inline SuwayyahEvents& operator=(const SuwayyahEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SuwayyahEvents& default_instance();

  void Swap(SuwayyahEvents* other);

  // implements Message ----------------------------------------------

  SuwayyahEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SuwayyahEvents& from);
  void MergeFrom(const SuwayyahEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SuwayyahEvents_Suwayyah Suwayyah;

  typedef SuwayyahEvents_ESEType ESEType;
  static const ESEType ESET_SINGLE = SuwayyahEvents_ESEType_ESET_SINGLE;
  static const ESEType ESET_SINGLE_AREA = SuwayyahEvents_ESEType_ESET_SINGLE_AREA;
  static const ESEType ESET_LEFT_AREA = SuwayyahEvents_ESEType_ESET_LEFT_AREA;
  static const ESEType ESET_RIGHT_AREA = SuwayyahEvents_ESEType_ESET_RIGHT_AREA;
  static inline bool ESEType_IsValid(int value) {
    return SuwayyahEvents_ESEType_IsValid(value);
  }
  static const ESEType ESEType_MIN =
    SuwayyahEvents_ESEType_ESEType_MIN;
  static const ESEType ESEType_MAX =
    SuwayyahEvents_ESEType_ESEType_MAX;
  static const int ESEType_ARRAYSIZE =
    SuwayyahEvents_ESEType_ESEType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ESEType_descriptor() {
    return SuwayyahEvents_ESEType_descriptor();
  }
  static inline const ::std::string& ESEType_Name(ESEType value) {
    return SuwayyahEvents_ESEType_Name(value);
  }
  static inline bool ESEType_Parse(const ::std::string& name,
      ESEType* value) {
    return SuwayyahEvents_ESEType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.SuwayyahEvents.Suwayyah xSuwayyahList = 1;
  inline int xsuwayyahlist_size() const;
  inline void clear_xsuwayyahlist();
  static const int kXSuwayyahListFieldNumber = 1;
  inline const ::NFFS::SuwayyahEvents_Suwayyah& xsuwayyahlist(int index) const;
  inline ::NFFS::SuwayyahEvents_Suwayyah* mutable_xsuwayyahlist(int index);
  inline ::NFFS::SuwayyahEvents_Suwayyah* add_xsuwayyahlist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::SuwayyahEvents_Suwayyah >&
      xsuwayyahlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::SuwayyahEvents_Suwayyah >*
      mutable_xsuwayyahlist();

  // @@protoc_insertion_point(class_scope:NFFS.SuwayyahEvents)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::SuwayyahEvents_Suwayyah > xsuwayyahlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static SuwayyahEvents* default_instance_;
};
// -------------------------------------------------------------------

class BulletEvents_TacheBomp : public ::google::protobuf::Message {
 public:
  BulletEvents_TacheBomp();
  virtual ~BulletEvents_TacheBomp();

  BulletEvents_TacheBomp(const BulletEvents_TacheBomp& from);

  inline BulletEvents_TacheBomp& operator=(const BulletEvents_TacheBomp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulletEvents_TacheBomp& default_instance();

  void Swap(BulletEvents_TacheBomp* other);

  // implements Message ----------------------------------------------

  BulletEvents_TacheBomp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulletEvents_TacheBomp& from);
  void MergeFrom(const BulletEvents_TacheBomp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float BompTime = 1;
  inline bool has_bomptime() const;
  inline void clear_bomptime();
  static const int kBompTimeFieldNumber = 1;
  inline float bomptime() const;
  inline void set_bomptime(float value);

  // required float BompRang = 2;
  inline bool has_bomprang() const;
  inline void clear_bomprang();
  static const int kBompRangFieldNumber = 2;
  inline float bomprang() const;
  inline void set_bomprang(float value);

  // required string BompPrefabPath = 3;
  inline bool has_bompprefabpath() const;
  inline void clear_bompprefabpath();
  static const int kBompPrefabPathFieldNumber = 3;
  inline const ::std::string& bompprefabpath() const;
  inline void set_bompprefabpath(const ::std::string& value);
  inline void set_bompprefabpath(const char* value);
  inline void set_bompprefabpath(const char* value, size_t size);
  inline ::std::string* mutable_bompprefabpath();
  inline ::std::string* release_bompprefabpath();
  inline void set_allocated_bompprefabpath(::std::string* bompprefabpath);

  // required string BeAttackParticle = 4;
  inline bool has_beattackparticle() const;
  inline void clear_beattackparticle();
  static const int kBeAttackParticleFieldNumber = 4;
  inline const ::std::string& beattackparticle() const;
  inline void set_beattackparticle(const ::std::string& value);
  inline void set_beattackparticle(const char* value);
  inline void set_beattackparticle(const char* value, size_t size);
  inline ::std::string* mutable_beattackparticle();
  inline ::std::string* release_beattackparticle();
  inline void set_allocated_beattackparticle(::std::string* beattackparticle);

  // required float BackNpcDis = 5;
  inline bool has_backnpcdis() const;
  inline void clear_backnpcdis();
  static const int kBackNpcDisFieldNumber = 5;
  inline float backnpcdis() const;
  inline void set_backnpcdis(float value);

  // required float BackHeroDis = 6;
  inline bool has_backherodis() const;
  inline void clear_backherodis();
  static const int kBackHeroDisFieldNumber = 6;
  inline float backherodis() const;
  inline void set_backherodis(float value);

  // required string MethodCall = 7;
  inline bool has_methodcall() const;
  inline void clear_methodcall();
  static const int kMethodCallFieldNumber = 7;
  inline const ::std::string& methodcall() const;
  inline void set_methodcall(const ::std::string& value);
  inline void set_methodcall(const char* value);
  inline void set_methodcall(const char* value, size_t size);
  inline ::std::string* mutable_methodcall();
  inline ::std::string* release_methodcall();
  inline void set_allocated_methodcall(::std::string* methodcall);

  // required string MethodParam = 8;
  inline bool has_methodparam() const;
  inline void clear_methodparam();
  static const int kMethodParamFieldNumber = 8;
  inline const ::std::string& methodparam() const;
  inline void set_methodparam(const ::std::string& value);
  inline void set_methodparam(const char* value);
  inline void set_methodparam(const char* value, size_t size);
  inline ::std::string* mutable_methodparam();
  inline ::std::string* release_methodparam();
  inline void set_allocated_methodparam(::std::string* methodparam);

  // required string TargetMethodCall = 9;
  inline bool has_targetmethodcall() const;
  inline void clear_targetmethodcall();
  static const int kTargetMethodCallFieldNumber = 9;
  inline const ::std::string& targetmethodcall() const;
  inline void set_targetmethodcall(const ::std::string& value);
  inline void set_targetmethodcall(const char* value);
  inline void set_targetmethodcall(const char* value, size_t size);
  inline ::std::string* mutable_targetmethodcall();
  inline ::std::string* release_targetmethodcall();
  inline void set_allocated_targetmethodcall(::std::string* targetmethodcall);

  // required string TargetMethodParam = 10;
  inline bool has_targetmethodparam() const;
  inline void clear_targetmethodparam();
  static const int kTargetMethodParamFieldNumber = 10;
  inline const ::std::string& targetmethodparam() const;
  inline void set_targetmethodparam(const ::std::string& value);
  inline void set_targetmethodparam(const char* value);
  inline void set_targetmethodparam(const char* value, size_t size);
  inline ::std::string* mutable_targetmethodparam();
  inline ::std::string* release_targetmethodparam();
  inline void set_allocated_targetmethodparam(::std::string* targetmethodparam);

  // @@protoc_insertion_point(class_scope:NFFS.BulletEvents.TacheBomp)
 private:
  inline void set_has_bomptime();
  inline void clear_has_bomptime();
  inline void set_has_bomprang();
  inline void clear_has_bomprang();
  inline void set_has_bompprefabpath();
  inline void clear_has_bompprefabpath();
  inline void set_has_beattackparticle();
  inline void clear_has_beattackparticle();
  inline void set_has_backnpcdis();
  inline void clear_has_backnpcdis();
  inline void set_has_backherodis();
  inline void clear_has_backherodis();
  inline void set_has_methodcall();
  inline void clear_has_methodcall();
  inline void set_has_methodparam();
  inline void clear_has_methodparam();
  inline void set_has_targetmethodcall();
  inline void clear_has_targetmethodcall();
  inline void set_has_targetmethodparam();
  inline void clear_has_targetmethodparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float bomptime_;
  float bomprang_;
  ::std::string* bompprefabpath_;
  ::std::string* beattackparticle_;
  float backnpcdis_;
  float backherodis_;
  ::std::string* methodcall_;
  ::std::string* methodparam_;
  ::std::string* targetmethodcall_;
  ::std::string* targetmethodparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static BulletEvents_TacheBomp* default_instance_;
};
// -------------------------------------------------------------------

class BulletEvents_Bullet : public ::google::protobuf::Message {
 public:
  BulletEvents_Bullet();
  virtual ~BulletEvents_Bullet();

  BulletEvents_Bullet(const BulletEvents_Bullet& from);

  inline BulletEvents_Bullet& operator=(const BulletEvents_Bullet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulletEvents_Bullet& default_instance();

  void Swap(BulletEvents_Bullet* other);

  // implements Message ----------------------------------------------

  BulletEvents_Bullet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulletEvents_Bullet& from);
  void MergeFrom(const BulletEvents_Bullet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float EventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.BulletEvents.EBEType EventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::BulletEvents_EBEType eventtype() const;
  inline void set_eventtype(::NFFS::BulletEvents_EBEType value);

  // required float Speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline float speed() const;
  inline void set_speed(float value);

  // required float MaxDis = 4;
  inline bool has_maxdis() const;
  inline void clear_maxdis();
  static const int kMaxDisFieldNumber = 4;
  inline float maxdis() const;
  inline void set_maxdis(float value);

  // required float BulletRang = 5;
  inline bool has_bulletrang() const;
  inline void clear_bulletrang();
  static const int kBulletRangFieldNumber = 5;
  inline float bulletrang() const;
  inline void set_bulletrang(float value);

  // required .NFFS.BulletEvents.EBE_BACKType BulletBackType = 6;
  inline bool has_bulletbacktype() const;
  inline void clear_bulletbacktype();
  static const int kBulletBackTypeFieldNumber = 6;
  inline ::NFFS::BulletEvents_EBE_BACKType bulletbacktype() const;
  inline void set_bulletbacktype(::NFFS::BulletEvents_EBE_BACKType value);

  // required float BackHeroDis = 7;
  inline bool has_backherodis() const;
  inline void clear_backherodis();
  static const int kBackHeroDisFieldNumber = 7;
  inline float backherodis() const;
  inline void set_backherodis(float value);

  // required float BackNpcDis = 8;
  inline bool has_backnpcdis() const;
  inline void clear_backnpcdis();
  static const int kBackNpcDisFieldNumber = 8;
  inline float backnpcdis() const;
  inline void set_backnpcdis(float value);

  // required int32 TacheDetroy = 9;
  inline bool has_tachedetroy() const;
  inline void clear_tachedetroy();
  static const int kTacheDetroyFieldNumber = 9;
  inline ::google::protobuf::int32 tachedetroy() const;
  inline void set_tachedetroy(::google::protobuf::int32 value);

  // required string BeAttackParticle = 10;
  inline bool has_beattackparticle() const;
  inline void clear_beattackparticle();
  static const int kBeAttackParticleFieldNumber = 10;
  inline const ::std::string& beattackparticle() const;
  inline void set_beattackparticle(const ::std::string& value);
  inline void set_beattackparticle(const char* value);
  inline void set_beattackparticle(const char* value, size_t size);
  inline ::std::string* mutable_beattackparticle();
  inline ::std::string* release_beattackparticle();
  inline void set_allocated_beattackparticle(::std::string* beattackparticle);

  // required string FireTacheName = 11;
  inline bool has_firetachename() const;
  inline void clear_firetachename();
  static const int kFireTacheNameFieldNumber = 11;
  inline const ::std::string& firetachename() const;
  inline void set_firetachename(const ::std::string& value);
  inline void set_firetachename(const char* value);
  inline void set_firetachename(const char* value, size_t size);
  inline ::std::string* mutable_firetachename();
  inline ::std::string* release_firetachename();
  inline void set_allocated_firetachename(::std::string* firetachename);

  // required .NFFS.FSVector3 FireTacheOffest = 12;
  inline bool has_firetacheoffest() const;
  inline void clear_firetacheoffest();
  static const int kFireTacheOffestFieldNumber = 12;
  inline const ::NFFS::FSVector3& firetacheoffest() const;
  inline ::NFFS::FSVector3* mutable_firetacheoffest();
  inline ::NFFS::FSVector3* release_firetacheoffest();
  inline void set_allocated_firetacheoffest(::NFFS::FSVector3* firetacheoffest);

  // required string BulletPrefabPath = 13;
  inline bool has_bulletprefabpath() const;
  inline void clear_bulletprefabpath();
  static const int kBulletPrefabPathFieldNumber = 13;
  inline const ::std::string& bulletprefabpath() const;
  inline void set_bulletprefabpath(const ::std::string& value);
  inline void set_bulletprefabpath(const char* value);
  inline void set_bulletprefabpath(const char* value, size_t size);
  inline ::std::string* mutable_bulletprefabpath();
  inline ::std::string* release_bulletprefabpath();
  inline void set_allocated_bulletprefabpath(::std::string* bulletprefabpath);

  // required string MethodCall = 14;
  inline bool has_methodcall() const;
  inline void clear_methodcall();
  static const int kMethodCallFieldNumber = 14;
  inline const ::std::string& methodcall() const;
  inline void set_methodcall(const ::std::string& value);
  inline void set_methodcall(const char* value);
  inline void set_methodcall(const char* value, size_t size);
  inline ::std::string* mutable_methodcall();
  inline ::std::string* release_methodcall();
  inline void set_allocated_methodcall(::std::string* methodcall);

  // required string MethodParam = 15;
  inline bool has_methodparam() const;
  inline void clear_methodparam();
  static const int kMethodParamFieldNumber = 15;
  inline const ::std::string& methodparam() const;
  inline void set_methodparam(const ::std::string& value);
  inline void set_methodparam(const char* value);
  inline void set_methodparam(const char* value, size_t size);
  inline ::std::string* mutable_methodparam();
  inline ::std::string* release_methodparam();
  inline void set_allocated_methodparam(::std::string* methodparam);

  // required string TargetMethodCall = 16;
  inline bool has_targetmethodcall() const;
  inline void clear_targetmethodcall();
  static const int kTargetMethodCallFieldNumber = 16;
  inline const ::std::string& targetmethodcall() const;
  inline void set_targetmethodcall(const ::std::string& value);
  inline void set_targetmethodcall(const char* value);
  inline void set_targetmethodcall(const char* value, size_t size);
  inline ::std::string* mutable_targetmethodcall();
  inline ::std::string* release_targetmethodcall();
  inline void set_allocated_targetmethodcall(::std::string* targetmethodcall);

  // required string TargetMethodParam = 17;
  inline bool has_targetmethodparam() const;
  inline void clear_targetmethodparam();
  static const int kTargetMethodParamFieldNumber = 17;
  inline const ::std::string& targetmethodparam() const;
  inline void set_targetmethodparam(const ::std::string& value);
  inline void set_targetmethodparam(const char* value);
  inline void set_targetmethodparam(const char* value, size_t size);
  inline ::std::string* mutable_targetmethodparam();
  inline ::std::string* release_targetmethodparam();
  inline void set_allocated_targetmethodparam(::std::string* targetmethodparam);

  // repeated .NFFS.BulletEvents.TacheBomp Bomp = 18;
  inline int bomp_size() const;
  inline void clear_bomp();
  static const int kBompFieldNumber = 18;
  inline const ::NFFS::BulletEvents_TacheBomp& bomp(int index) const;
  inline ::NFFS::BulletEvents_TacheBomp* mutable_bomp(int index);
  inline ::NFFS::BulletEvents_TacheBomp* add_bomp();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_TacheBomp >&
      bomp() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_TacheBomp >*
      mutable_bomp();

  // @@protoc_insertion_point(class_scope:NFFS.BulletEvents.Bullet)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_maxdis();
  inline void clear_has_maxdis();
  inline void set_has_bulletrang();
  inline void clear_has_bulletrang();
  inline void set_has_bulletbacktype();
  inline void clear_has_bulletbacktype();
  inline void set_has_backherodis();
  inline void clear_has_backherodis();
  inline void set_has_backnpcdis();
  inline void clear_has_backnpcdis();
  inline void set_has_tachedetroy();
  inline void clear_has_tachedetroy();
  inline void set_has_beattackparticle();
  inline void clear_has_beattackparticle();
  inline void set_has_firetachename();
  inline void clear_has_firetachename();
  inline void set_has_firetacheoffest();
  inline void clear_has_firetacheoffest();
  inline void set_has_bulletprefabpath();
  inline void clear_has_bulletprefabpath();
  inline void set_has_methodcall();
  inline void clear_has_methodcall();
  inline void set_has_methodparam();
  inline void clear_has_methodparam();
  inline void set_has_targetmethodcall();
  inline void clear_has_targetmethodcall();
  inline void set_has_targetmethodparam();
  inline void clear_has_targetmethodparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  float speed_;
  float maxdis_;
  float bulletrang_;
  int bulletbacktype_;
  float backherodis_;
  float backnpcdis_;
  ::std::string* beattackparticle_;
  ::std::string* firetachename_;
  ::NFFS::FSVector3* firetacheoffest_;
  ::std::string* bulletprefabpath_;
  ::std::string* methodcall_;
  ::std::string* methodparam_;
  ::std::string* targetmethodcall_;
  ::std::string* targetmethodparam_;
  ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_TacheBomp > bomp_;
  ::google::protobuf::int32 tachedetroy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static BulletEvents_Bullet* default_instance_;
};
// -------------------------------------------------------------------

class BulletEvents : public ::google::protobuf::Message {
 public:
  BulletEvents();
  virtual ~BulletEvents();

  BulletEvents(const BulletEvents& from);

  inline BulletEvents& operator=(const BulletEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulletEvents& default_instance();

  void Swap(BulletEvents* other);

  // implements Message ----------------------------------------------

  BulletEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulletEvents& from);
  void MergeFrom(const BulletEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BulletEvents_TacheBomp TacheBomp;
  typedef BulletEvents_Bullet Bullet;

  typedef BulletEvents_EBEType EBEType;
  static const EBEType ESET_TARGET = BulletEvents_EBEType_ESET_TARGET;
  static const EBEType ESET_POSITION = BulletEvents_EBEType_ESET_POSITION;
  static inline bool EBEType_IsValid(int value) {
    return BulletEvents_EBEType_IsValid(value);
  }
  static const EBEType EBEType_MIN =
    BulletEvents_EBEType_EBEType_MIN;
  static const EBEType EBEType_MAX =
    BulletEvents_EBEType_EBEType_MAX;
  static const int EBEType_ARRAYSIZE =
    BulletEvents_EBEType_EBEType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EBEType_descriptor() {
    return BulletEvents_EBEType_descriptor();
  }
  static inline const ::std::string& EBEType_Name(EBEType value) {
    return BulletEvents_EBEType_Name(value);
  }
  static inline bool EBEType_Parse(const ::std::string& name,
      EBEType* value) {
    return BulletEvents_EBEType_Parse(name, value);
  }

  typedef BulletEvents_EBE_BACKType EBE_BACKType;
  static const EBE_BACKType EBEBT_BACK = BulletEvents_EBE_BACKType_EBEBT_BACK;
  static const EBE_BACKType EBEBT_SIDE = BulletEvents_EBE_BACKType_EBEBT_SIDE;
  static inline bool EBE_BACKType_IsValid(int value) {
    return BulletEvents_EBE_BACKType_IsValid(value);
  }
  static const EBE_BACKType EBE_BACKType_MIN =
    BulletEvents_EBE_BACKType_EBE_BACKType_MIN;
  static const EBE_BACKType EBE_BACKType_MAX =
    BulletEvents_EBE_BACKType_EBE_BACKType_MAX;
  static const int EBE_BACKType_ARRAYSIZE =
    BulletEvents_EBE_BACKType_EBE_BACKType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EBE_BACKType_descriptor() {
    return BulletEvents_EBE_BACKType_descriptor();
  }
  static inline const ::std::string& EBE_BACKType_Name(EBE_BACKType value) {
    return BulletEvents_EBE_BACKType_Name(value);
  }
  static inline bool EBE_BACKType_Parse(const ::std::string& name,
      EBE_BACKType* value) {
    return BulletEvents_EBE_BACKType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.BulletEvents.Bullet xBulletList = 1;
  inline int xbulletlist_size() const;
  inline void clear_xbulletlist();
  static const int kXBulletListFieldNumber = 1;
  inline const ::NFFS::BulletEvents_Bullet& xbulletlist(int index) const;
  inline ::NFFS::BulletEvents_Bullet* mutable_xbulletlist(int index);
  inline ::NFFS::BulletEvents_Bullet* add_xbulletlist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_Bullet >&
      xbulletlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_Bullet >*
      mutable_xbulletlist();

  // @@protoc_insertion_point(class_scope:NFFS.BulletEvents)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_Bullet > xbulletlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static BulletEvents* default_instance_;
};
// -------------------------------------------------------------------

class AnimatorMoves_Move : public ::google::protobuf::Message {
 public:
  AnimatorMoves_Move();
  virtual ~AnimatorMoves_Move();

  AnimatorMoves_Move(const AnimatorMoves_Move& from);

  inline AnimatorMoves_Move& operator=(const AnimatorMoves_Move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnimatorMoves_Move& default_instance();

  void Swap(AnimatorMoves_Move* other);

  // implements Message ----------------------------------------------

  AnimatorMoves_Move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnimatorMoves_Move& from);
  void MergeFrom(const AnimatorMoves_Move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float EventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.AnimatorMoves.EAMType EventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::AnimatorMoves_EAMType eventtype() const;
  inline void set_eventtype(::NFFS::AnimatorMoves_EAMType value);

  // required float MoveDis = 3;
  inline bool has_movedis() const;
  inline void clear_movedis();
  static const int kMoveDisFieldNumber = 3;
  inline float movedis() const;
  inline void set_movedis(float value);

  // required float MoveTime = 4;
  inline bool has_movetime() const;
  inline void clear_movetime();
  static const int kMoveTimeFieldNumber = 4;
  inline float movetime() const;
  inline void set_movetime(float value);

  // required string MethodCall = 5;
  inline bool has_methodcall() const;
  inline void clear_methodcall();
  static const int kMethodCallFieldNumber = 5;
  inline const ::std::string& methodcall() const;
  inline void set_methodcall(const ::std::string& value);
  inline void set_methodcall(const char* value);
  inline void set_methodcall(const char* value, size_t size);
  inline ::std::string* mutable_methodcall();
  inline ::std::string* release_methodcall();
  inline void set_allocated_methodcall(::std::string* methodcall);

  // required string MethodParam = 6;
  inline bool has_methodparam() const;
  inline void clear_methodparam();
  static const int kMethodParamFieldNumber = 6;
  inline const ::std::string& methodparam() const;
  inline void set_methodparam(const ::std::string& value);
  inline void set_methodparam(const char* value);
  inline void set_methodparam(const char* value, size_t size);
  inline ::std::string* mutable_methodparam();
  inline ::std::string* release_methodparam();
  inline void set_allocated_methodparam(::std::string* methodparam);

  // @@protoc_insertion_point(class_scope:NFFS.AnimatorMoves.Move)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_movedis();
  inline void clear_has_movedis();
  inline void set_has_movetime();
  inline void clear_has_movetime();
  inline void set_has_methodcall();
  inline void clear_has_methodcall();
  inline void set_has_methodparam();
  inline void clear_has_methodparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  float movedis_;
  float movetime_;
  ::std::string* methodcall_;
  ::std::string* methodparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static AnimatorMoves_Move* default_instance_;
};
// -------------------------------------------------------------------

class AnimatorMoves : public ::google::protobuf::Message {
 public:
  AnimatorMoves();
  virtual ~AnimatorMoves();

  AnimatorMoves(const AnimatorMoves& from);

  inline AnimatorMoves& operator=(const AnimatorMoves& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnimatorMoves& default_instance();

  void Swap(AnimatorMoves* other);

  // implements Message ----------------------------------------------

  AnimatorMoves* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnimatorMoves& from);
  void MergeFrom(const AnimatorMoves& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AnimatorMoves_Move Move;

  typedef AnimatorMoves_EAMType EAMType;
  static const EAMType EAMT_FORWARD = AnimatorMoves_EAMType_EAMT_FORWARD;
  static const EAMType EAMT_BACK = AnimatorMoves_EAMType_EAMT_BACK;
  static const EAMType EAMT_LEFT = AnimatorMoves_EAMType_EAMT_LEFT;
  static const EAMType EAMT_RIGHT = AnimatorMoves_EAMType_EAMT_RIGHT;
  static inline bool EAMType_IsValid(int value) {
    return AnimatorMoves_EAMType_IsValid(value);
  }
  static const EAMType EAMType_MIN =
    AnimatorMoves_EAMType_EAMType_MIN;
  static const EAMType EAMType_MAX =
    AnimatorMoves_EAMType_EAMType_MAX;
  static const int EAMType_ARRAYSIZE =
    AnimatorMoves_EAMType_EAMType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EAMType_descriptor() {
    return AnimatorMoves_EAMType_descriptor();
  }
  static inline const ::std::string& EAMType_Name(EAMType value) {
    return AnimatorMoves_EAMType_Name(value);
  }
  static inline bool EAMType_Parse(const ::std::string& name,
      EAMType* value) {
    return AnimatorMoves_EAMType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.AnimatorMoves.Move xMoveList = 1;
  inline int xmovelist_size() const;
  inline void clear_xmovelist();
  static const int kXMoveListFieldNumber = 1;
  inline const ::NFFS::AnimatorMoves_Move& xmovelist(int index) const;
  inline ::NFFS::AnimatorMoves_Move* mutable_xmovelist(int index);
  inline ::NFFS::AnimatorMoves_Move* add_xmovelist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::AnimatorMoves_Move >&
      xmovelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::AnimatorMoves_Move >*
      mutable_xmovelist();

  // @@protoc_insertion_point(class_scope:NFFS.AnimatorMoves)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::AnimatorMoves_Move > xmovelist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static AnimatorMoves* default_instance_;
};
// -------------------------------------------------------------------

class CameraControlEvents_Camera : public ::google::protobuf::Message {
 public:
  CameraControlEvents_Camera();
  virtual ~CameraControlEvents_Camera();

  CameraControlEvents_Camera(const CameraControlEvents_Camera& from);

  inline CameraControlEvents_Camera& operator=(const CameraControlEvents_Camera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraControlEvents_Camera& default_instance();

  void Swap(CameraControlEvents_Camera* other);

  // implements Message ----------------------------------------------

  CameraControlEvents_Camera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraControlEvents_Camera& from);
  void MergeFrom(const CameraControlEvents_Camera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float EventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.CameraControlEvents.ECEType EventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::CameraControlEvents_ECEType eventtype() const;
  inline void set_eventtype(::NFFS::CameraControlEvents_ECEType value);

  // required .NFFS.FSVector3 AmountParam = 3;
  inline bool has_amountparam() const;
  inline void clear_amountparam();
  static const int kAmountParamFieldNumber = 3;
  inline const ::NFFS::FSVector3& amountparam() const;
  inline ::NFFS::FSVector3* mutable_amountparam();
  inline ::NFFS::FSVector3* release_amountparam();
  inline void set_allocated_amountparam(::NFFS::FSVector3* amountparam);

  // required float ShakeTime = 4;
  inline bool has_shaketime() const;
  inline void clear_shaketime();
  static const int kShakeTimeFieldNumber = 4;
  inline float shaketime() const;
  inline void set_shaketime(float value);

  // required string MethodCall = 5;
  inline bool has_methodcall() const;
  inline void clear_methodcall();
  static const int kMethodCallFieldNumber = 5;
  inline const ::std::string& methodcall() const;
  inline void set_methodcall(const ::std::string& value);
  inline void set_methodcall(const char* value);
  inline void set_methodcall(const char* value, size_t size);
  inline ::std::string* mutable_methodcall();
  inline ::std::string* release_methodcall();
  inline void set_allocated_methodcall(::std::string* methodcall);

  // required string MethodParam = 6;
  inline bool has_methodparam() const;
  inline void clear_methodparam();
  static const int kMethodParamFieldNumber = 6;
  inline const ::std::string& methodparam() const;
  inline void set_methodparam(const ::std::string& value);
  inline void set_methodparam(const char* value);
  inline void set_methodparam(const char* value, size_t size);
  inline ::std::string* mutable_methodparam();
  inline ::std::string* release_methodparam();
  inline void set_allocated_methodparam(::std::string* methodparam);

  // @@protoc_insertion_point(class_scope:NFFS.CameraControlEvents.Camera)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_amountparam();
  inline void clear_has_amountparam();
  inline void set_has_shaketime();
  inline void clear_has_shaketime();
  inline void set_has_methodcall();
  inline void clear_has_methodcall();
  inline void set_has_methodparam();
  inline void clear_has_methodparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  ::NFFS::FSVector3* amountparam_;
  ::std::string* methodcall_;
  ::std::string* methodparam_;
  float shaketime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static CameraControlEvents_Camera* default_instance_;
};
// -------------------------------------------------------------------

class CameraControlEvents : public ::google::protobuf::Message {
 public:
  CameraControlEvents();
  virtual ~CameraControlEvents();

  CameraControlEvents(const CameraControlEvents& from);

  inline CameraControlEvents& operator=(const CameraControlEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraControlEvents& default_instance();

  void Swap(CameraControlEvents* other);

  // implements Message ----------------------------------------------

  CameraControlEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraControlEvents& from);
  void MergeFrom(const CameraControlEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CameraControlEvents_Camera Camera;

  typedef CameraControlEvents_ECEType ECEType;
  static const ECEType Earthquake = CameraControlEvents_ECEType_Earthquake;
  static const ECEType Explosion = CameraControlEvents_ECEType_Explosion;
  static const ECEType No = CameraControlEvents_ECEType_No;
  static const ECEType FireKick = CameraControlEvents_ECEType_FireKick;
  static const ECEType Stomp = CameraControlEvents_ECEType_Stomp;
  static const ECEType Yes = CameraControlEvents_ECEType_Yes;
  static const ECEType SprintShake = CameraControlEvents_ECEType_SprintShake;
  static const ECEType FreeMode = CameraControlEvents_ECEType_FreeMode;
  static const ECEType MainRPGMode = CameraControlEvents_ECEType_MainRPGMode;
  static inline bool ECEType_IsValid(int value) {
    return CameraControlEvents_ECEType_IsValid(value);
  }
  static const ECEType ECEType_MIN =
    CameraControlEvents_ECEType_ECEType_MIN;
  static const ECEType ECEType_MAX =
    CameraControlEvents_ECEType_ECEType_MAX;
  static const int ECEType_ARRAYSIZE =
    CameraControlEvents_ECEType_ECEType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ECEType_descriptor() {
    return CameraControlEvents_ECEType_descriptor();
  }
  static inline const ::std::string& ECEType_Name(ECEType value) {
    return CameraControlEvents_ECEType_Name(value);
  }
  static inline bool ECEType_Parse(const ::std::string& name,
      ECEType* value) {
    return CameraControlEvents_ECEType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.CameraControlEvents.Camera xCameraList = 1;
  inline int xcameralist_size() const;
  inline void clear_xcameralist();
  static const int kXCameraListFieldNumber = 1;
  inline const ::NFFS::CameraControlEvents_Camera& xcameralist(int index) const;
  inline ::NFFS::CameraControlEvents_Camera* mutable_xcameralist(int index);
  inline ::NFFS::CameraControlEvents_Camera* add_xcameralist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::CameraControlEvents_Camera >&
      xcameralist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::CameraControlEvents_Camera >*
      mutable_xcameralist();

  // @@protoc_insertion_point(class_scope:NFFS.CameraControlEvents)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::CameraControlEvents_Camera > xcameralist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static CameraControlEvents* default_instance_;
};
// -------------------------------------------------------------------

class ParticleEvents_Particle : public ::google::protobuf::Message {
 public:
  ParticleEvents_Particle();
  virtual ~ParticleEvents_Particle();

  ParticleEvents_Particle(const ParticleEvents_Particle& from);

  inline ParticleEvents_Particle& operator=(const ParticleEvents_Particle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParticleEvents_Particle& default_instance();

  void Swap(ParticleEvents_Particle* other);

  // implements Message ----------------------------------------------

  ParticleEvents_Particle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParticleEvents_Particle& from);
  void MergeFrom(const ParticleEvents_Particle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float EventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.ParticleEvents.EPERTYPE Rotation = 3;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 3;
  inline ::NFFS::ParticleEvents_EPERTYPE rotation() const;
  inline void set_rotation(::NFFS::ParticleEvents_EPERTYPE value);

  // required string ParticlePath = 4;
  inline bool has_particlepath() const;
  inline void clear_particlepath();
  static const int kParticlePathFieldNumber = 4;
  inline const ::std::string& particlepath() const;
  inline void set_particlepath(const ::std::string& value);
  inline void set_particlepath(const char* value);
  inline void set_particlepath(const char* value, size_t size);
  inline ::std::string* mutable_particlepath();
  inline ::std::string* release_particlepath();
  inline void set_allocated_particlepath(::std::string* particlepath);

  // required string TargetTacheName = 5;
  inline bool has_targettachename() const;
  inline void clear_targettachename();
  static const int kTargetTacheNameFieldNumber = 5;
  inline const ::std::string& targettachename() const;
  inline void set_targettachename(const ::std::string& value);
  inline void set_targettachename(const char* value);
  inline void set_targettachename(const char* value, size_t size);
  inline ::std::string* mutable_targettachename();
  inline ::std::string* release_targettachename();
  inline void set_allocated_targettachename(::std::string* targettachename);

  // required .NFFS.FSVector3 TargetTacheOffest = 6;
  inline bool has_targettacheoffest() const;
  inline void clear_targettacheoffest();
  static const int kTargetTacheOffestFieldNumber = 6;
  inline const ::NFFS::FSVector3& targettacheoffest() const;
  inline ::NFFS::FSVector3* mutable_targettacheoffest();
  inline ::NFFS::FSVector3* release_targettacheoffest();
  inline void set_allocated_targettacheoffest(::NFFS::FSVector3* targettacheoffest);

  // required int32 CastToSurface = 7;
  inline bool has_casttosurface() const;
  inline void clear_casttosurface();
  static const int kCastToSurfaceFieldNumber = 7;
  inline ::google::protobuf::int32 casttosurface() const;
  inline void set_casttosurface(::google::protobuf::int32 value);

  // required int32 BindTarget = 8;
  inline bool has_bindtarget() const;
  inline void clear_bindtarget();
  static const int kBindTargetFieldNumber = 8;
  inline ::google::protobuf::int32 bindtarget() const;
  inline void set_bindtarget(::google::protobuf::int32 value);

  // required string MethodCall = 9;
  inline bool has_methodcall() const;
  inline void clear_methodcall();
  static const int kMethodCallFieldNumber = 9;
  inline const ::std::string& methodcall() const;
  inline void set_methodcall(const ::std::string& value);
  inline void set_methodcall(const char* value);
  inline void set_methodcall(const char* value, size_t size);
  inline ::std::string* mutable_methodcall();
  inline ::std::string* release_methodcall();
  inline void set_allocated_methodcall(::std::string* methodcall);

  // required string MethodParam = 10;
  inline bool has_methodparam() const;
  inline void clear_methodparam();
  static const int kMethodParamFieldNumber = 10;
  inline const ::std::string& methodparam() const;
  inline void set_methodparam(const ::std::string& value);
  inline void set_methodparam(const char* value);
  inline void set_methodparam(const char* value, size_t size);
  inline ::std::string* mutable_methodparam();
  inline ::std::string* release_methodparam();
  inline void set_allocated_methodparam(::std::string* methodparam);

  // @@protoc_insertion_point(class_scope:NFFS.ParticleEvents.Particle)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_particlepath();
  inline void clear_has_particlepath();
  inline void set_has_targettachename();
  inline void clear_has_targettachename();
  inline void set_has_targettacheoffest();
  inline void clear_has_targettacheoffest();
  inline void set_has_casttosurface();
  inline void clear_has_casttosurface();
  inline void set_has_bindtarget();
  inline void clear_has_bindtarget();
  inline void set_has_methodcall();
  inline void clear_has_methodcall();
  inline void set_has_methodparam();
  inline void clear_has_methodparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int rotation_;
  ::std::string* particlepath_;
  ::std::string* targettachename_;
  ::NFFS::FSVector3* targettacheoffest_;
  ::google::protobuf::int32 casttosurface_;
  ::google::protobuf::int32 bindtarget_;
  ::std::string* methodcall_;
  ::std::string* methodparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static ParticleEvents_Particle* default_instance_;
};
// -------------------------------------------------------------------

class ParticleEvents : public ::google::protobuf::Message {
 public:
  ParticleEvents();
  virtual ~ParticleEvents();

  ParticleEvents(const ParticleEvents& from);

  inline ParticleEvents& operator=(const ParticleEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParticleEvents& default_instance();

  void Swap(ParticleEvents* other);

  // implements Message ----------------------------------------------

  ParticleEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParticleEvents& from);
  void MergeFrom(const ParticleEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ParticleEvents_Particle Particle;

  typedef ParticleEvents_EPERTYPE EPERTYPE;
  static const EPERTYPE NONE = ParticleEvents_EPERTYPE_NONE;
  static const EPERTYPE MatchTarget = ParticleEvents_EPERTYPE_MatchTarget;
  static const EPERTYPE Random_X = ParticleEvents_EPERTYPE_Random_X;
  static const EPERTYPE Random_Y = ParticleEvents_EPERTYPE_Random_Y;
  static const EPERTYPE Random_Z = ParticleEvents_EPERTYPE_Random_Z;
  static const EPERTYPE Random_XY = ParticleEvents_EPERTYPE_Random_XY;
  static const EPERTYPE Random_XZ = ParticleEvents_EPERTYPE_Random_XZ;
  static const EPERTYPE Random_YZ = ParticleEvents_EPERTYPE_Random_YZ;
  static const EPERTYPE Random_XYZ = ParticleEvents_EPERTYPE_Random_XYZ;
  static inline bool EPERTYPE_IsValid(int value) {
    return ParticleEvents_EPERTYPE_IsValid(value);
  }
  static const EPERTYPE EPERTYPE_MIN =
    ParticleEvents_EPERTYPE_EPERTYPE_MIN;
  static const EPERTYPE EPERTYPE_MAX =
    ParticleEvents_EPERTYPE_EPERTYPE_MAX;
  static const int EPERTYPE_ARRAYSIZE =
    ParticleEvents_EPERTYPE_EPERTYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EPERTYPE_descriptor() {
    return ParticleEvents_EPERTYPE_descriptor();
  }
  static inline const ::std::string& EPERTYPE_Name(EPERTYPE value) {
    return ParticleEvents_EPERTYPE_Name(value);
  }
  static inline bool EPERTYPE_Parse(const ::std::string& name,
      EPERTYPE* value) {
    return ParticleEvents_EPERTYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.ParticleEvents.Particle xParticleList = 1;
  inline int xparticlelist_size() const;
  inline void clear_xparticlelist();
  static const int kXParticleListFieldNumber = 1;
  inline const ::NFFS::ParticleEvents_Particle& xparticlelist(int index) const;
  inline ::NFFS::ParticleEvents_Particle* mutable_xparticlelist(int index);
  inline ::NFFS::ParticleEvents_Particle* add_xparticlelist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::ParticleEvents_Particle >&
      xparticlelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::ParticleEvents_Particle >*
      mutable_xparticlelist();

  // @@protoc_insertion_point(class_scope:NFFS.ParticleEvents)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::ParticleEvents_Particle > xparticlelist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static ParticleEvents* default_instance_;
};
// -------------------------------------------------------------------

class EnableEvents_Enable : public ::google::protobuf::Message {
 public:
  EnableEvents_Enable();
  virtual ~EnableEvents_Enable();

  EnableEvents_Enable(const EnableEvents_Enable& from);

  inline EnableEvents_Enable& operator=(const EnableEvents_Enable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableEvents_Enable& default_instance();

  void Swap(EnableEvents_Enable* other);

  // implements Message ----------------------------------------------

  EnableEvents_Enable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnableEvents_Enable& from);
  void MergeFrom(const EnableEvents_Enable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float EventTime = 1;
  inline bool has_eventtime() const;
  inline void clear_eventtime();
  static const int kEventTimeFieldNumber = 1;
  inline float eventtime() const;
  inline void set_eventtime(float value);

  // required .NFFS.EnableEvents.EEETYPE EventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::NFFS::EnableEvents_EEETYPE eventtype() const;
  inline void set_eventtype(::NFFS::EnableEvents_EEETYPE value);

  // required string TargetName = 3;
  inline bool has_targetname() const;
  inline void clear_targetname();
  static const int kTargetNameFieldNumber = 3;
  inline const ::std::string& targetname() const;
  inline void set_targetname(const ::std::string& value);
  inline void set_targetname(const char* value);
  inline void set_targetname(const char* value, size_t size);
  inline ::std::string* mutable_targetname();
  inline ::std::string* release_targetname();
  inline void set_allocated_targetname(::std::string* targetname);

  // required string MethodCall = 4;
  inline bool has_methodcall() const;
  inline void clear_methodcall();
  static const int kMethodCallFieldNumber = 4;
  inline const ::std::string& methodcall() const;
  inline void set_methodcall(const ::std::string& value);
  inline void set_methodcall(const char* value);
  inline void set_methodcall(const char* value, size_t size);
  inline ::std::string* mutable_methodcall();
  inline ::std::string* release_methodcall();
  inline void set_allocated_methodcall(::std::string* methodcall);

  // required string MethodParam = 5;
  inline bool has_methodparam() const;
  inline void clear_methodparam();
  static const int kMethodParamFieldNumber = 5;
  inline const ::std::string& methodparam() const;
  inline void set_methodparam(const ::std::string& value);
  inline void set_methodparam(const char* value);
  inline void set_methodparam(const char* value, size_t size);
  inline ::std::string* mutable_methodparam();
  inline ::std::string* release_methodparam();
  inline void set_allocated_methodparam(::std::string* methodparam);

  // @@protoc_insertion_point(class_scope:NFFS.EnableEvents.Enable)
 private:
  inline void set_has_eventtime();
  inline void clear_has_eventtime();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_targetname();
  inline void clear_has_targetname();
  inline void set_has_methodcall();
  inline void clear_has_methodcall();
  inline void set_has_methodparam();
  inline void clear_has_methodparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float eventtime_;
  int eventtype_;
  ::std::string* targetname_;
  ::std::string* methodcall_;
  ::std::string* methodparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static EnableEvents_Enable* default_instance_;
};
// -------------------------------------------------------------------

class EnableEvents : public ::google::protobuf::Message {
 public:
  EnableEvents();
  virtual ~EnableEvents();

  EnableEvents(const EnableEvents& from);

  inline EnableEvents& operator=(const EnableEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableEvents& default_instance();

  void Swap(EnableEvents* other);

  // implements Message ----------------------------------------------

  EnableEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnableEvents& from);
  void MergeFrom(const EnableEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EnableEvents_Enable Enable;

  typedef EnableEvents_EEETYPE EEETYPE;
  static const EEETYPE INIT = EnableEvents_EEETYPE_INIT;
  static const EEETYPE FINAL = EnableEvents_EEETYPE_FINAL;
  static inline bool EEETYPE_IsValid(int value) {
    return EnableEvents_EEETYPE_IsValid(value);
  }
  static const EEETYPE EEETYPE_MIN =
    EnableEvents_EEETYPE_EEETYPE_MIN;
  static const EEETYPE EEETYPE_MAX =
    EnableEvents_EEETYPE_EEETYPE_MAX;
  static const int EEETYPE_ARRAYSIZE =
    EnableEvents_EEETYPE_EEETYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EEETYPE_descriptor() {
    return EnableEvents_EEETYPE_descriptor();
  }
  static inline const ::std::string& EEETYPE_Name(EEETYPE value) {
    return EnableEvents_EEETYPE_Name(value);
  }
  static inline bool EEETYPE_Parse(const ::std::string& name,
      EEETYPE* value) {
    return EnableEvents_EEETYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .NFFS.EnableEvents.Enable xEnableList = 1;
  inline int xenablelist_size() const;
  inline void clear_xenablelist();
  static const int kXEnableListFieldNumber = 1;
  inline const ::NFFS::EnableEvents_Enable& xenablelist(int index) const;
  inline ::NFFS::EnableEvents_Enable* mutable_xenablelist(int index);
  inline ::NFFS::EnableEvents_Enable* add_xenablelist();
  inline const ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable >&
      xenablelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable >*
      mutable_xenablelist();

  // @@protoc_insertion_point(class_scope:NFFS.EnableEvents)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable > xenablelist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_NFFleetingDefine_2eproto();
  friend void protobuf_AssignDesc_NFFleetingDefine_2eproto();
  friend void protobuf_ShutdownFile_NFFleetingDefine_2eproto();

  void InitAsDefaultInstance();
  static EnableEvents* default_instance_;
};
// ===================================================================


// ===================================================================

// FSVector3

// required float x = 1;
inline bool FSVector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FSVector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FSVector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FSVector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float FSVector3::x() const {
  return x_;
}
inline void FSVector3::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool FSVector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FSVector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FSVector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FSVector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float FSVector3::y() const {
  return y_;
}
inline void FSVector3::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool FSVector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FSVector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FSVector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FSVector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float FSVector3::z() const {
  return z_;
}
inline void FSVector3::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// SuwayyahEvents_Suwayyah

// required .NFFS.SuwayyahEvents.ESEType EventType = 1;
inline bool SuwayyahEvents_Suwayyah::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuwayyahEvents_Suwayyah::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::SuwayyahEvents_ESEType SuwayyahEvents_Suwayyah::eventtype() const {
  return static_cast< ::NFFS::SuwayyahEvents_ESEType >(eventtype_);
}
inline void SuwayyahEvents_Suwayyah::set_eventtype(::NFFS::SuwayyahEvents_ESEType value) {
  assert(::NFFS::SuwayyahEvents_ESEType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required float EventTime = 2;
inline bool SuwayyahEvents_Suwayyah::has_eventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_eventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuwayyahEvents_Suwayyah::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float SuwayyahEvents_Suwayyah::eventtime() const {
  return eventtime_;
}
inline void SuwayyahEvents_Suwayyah::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required float EndTime = 3;
inline bool SuwayyahEvents_Suwayyah::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SuwayyahEvents_Suwayyah::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline float SuwayyahEvents_Suwayyah::endtime() const {
  return endtime_;
}
inline void SuwayyahEvents_Suwayyah::set_endtime(float value) {
  set_has_endtime();
  endtime_ = value;
}

// required float DamageRang = 4;
inline bool SuwayyahEvents_Suwayyah::has_damagerang() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_damagerang() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_damagerang() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SuwayyahEvents_Suwayyah::clear_damagerang() {
  damagerang_ = 0;
  clear_has_damagerang();
}
inline float SuwayyahEvents_Suwayyah::damagerang() const {
  return damagerang_;
}
inline void SuwayyahEvents_Suwayyah::set_damagerang(float value) {
  set_has_damagerang();
  damagerang_ = value;
}

// required float BackHeroDis = 5;
inline bool SuwayyahEvents_Suwayyah::has_backherodis() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_backherodis() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_backherodis() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SuwayyahEvents_Suwayyah::clear_backherodis() {
  backherodis_ = 0;
  clear_has_backherodis();
}
inline float SuwayyahEvents_Suwayyah::backherodis() const {
  return backherodis_;
}
inline void SuwayyahEvents_Suwayyah::set_backherodis(float value) {
  set_has_backherodis();
  backherodis_ = value;
}

// required float BackNpcDis = 6;
inline bool SuwayyahEvents_Suwayyah::has_backnpcdis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_backnpcdis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_backnpcdis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SuwayyahEvents_Suwayyah::clear_backnpcdis() {
  backnpcdis_ = 0;
  clear_has_backnpcdis();
}
inline float SuwayyahEvents_Suwayyah::backnpcdis() const {
  return backnpcdis_;
}
inline void SuwayyahEvents_Suwayyah::set_backnpcdis(float value) {
  set_has_backnpcdis();
  backnpcdis_ = value;
}

// required string BeAttackParticle = 7;
inline bool SuwayyahEvents_Suwayyah::has_beattackparticle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_beattackparticle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_beattackparticle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SuwayyahEvents_Suwayyah::clear_beattackparticle() {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    beattackparticle_->clear();
  }
  clear_has_beattackparticle();
}
inline const ::std::string& SuwayyahEvents_Suwayyah::beattackparticle() const {
  return *beattackparticle_;
}
inline void SuwayyahEvents_Suwayyah::set_beattackparticle(const ::std::string& value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_beattackparticle(const char* value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_beattackparticle(const char* value, size_t size) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SuwayyahEvents_Suwayyah::mutable_beattackparticle() {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  return beattackparticle_;
}
inline ::std::string* SuwayyahEvents_Suwayyah::release_beattackparticle() {
  clear_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beattackparticle_;
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SuwayyahEvents_Suwayyah::set_allocated_beattackparticle(::std::string* beattackparticle) {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    delete beattackparticle_;
  }
  if (beattackparticle) {
    set_has_beattackparticle();
    beattackparticle_ = beattackparticle;
  } else {
    clear_has_beattackparticle();
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodCall = 8;
inline bool SuwayyahEvents_Suwayyah::has_methodcall() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_methodcall() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_methodcall() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SuwayyahEvents_Suwayyah::clear_methodcall() {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    methodcall_->clear();
  }
  clear_has_methodcall();
}
inline const ::std::string& SuwayyahEvents_Suwayyah::methodcall() const {
  return *methodcall_;
}
inline void SuwayyahEvents_Suwayyah::set_methodcall(const ::std::string& value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_methodcall(const char* value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_methodcall(const char* value, size_t size) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SuwayyahEvents_Suwayyah::mutable_methodcall() {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  return methodcall_;
}
inline ::std::string* SuwayyahEvents_Suwayyah::release_methodcall() {
  clear_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodcall_;
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SuwayyahEvents_Suwayyah::set_allocated_methodcall(::std::string* methodcall) {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete methodcall_;
  }
  if (methodcall) {
    set_has_methodcall();
    methodcall_ = methodcall;
  } else {
    clear_has_methodcall();
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodParam = 9;
inline bool SuwayyahEvents_Suwayyah::has_methodparam() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_methodparam() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_methodparam() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SuwayyahEvents_Suwayyah::clear_methodparam() {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    methodparam_->clear();
  }
  clear_has_methodparam();
}
inline const ::std::string& SuwayyahEvents_Suwayyah::methodparam() const {
  return *methodparam_;
}
inline void SuwayyahEvents_Suwayyah::set_methodparam(const ::std::string& value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_methodparam(const char* value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_methodparam(const char* value, size_t size) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SuwayyahEvents_Suwayyah::mutable_methodparam() {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  return methodparam_;
}
inline ::std::string* SuwayyahEvents_Suwayyah::release_methodparam() {
  clear_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodparam_;
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SuwayyahEvents_Suwayyah::set_allocated_methodparam(::std::string* methodparam) {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete methodparam_;
  }
  if (methodparam) {
    set_has_methodparam();
    methodparam_ = methodparam;
  } else {
    clear_has_methodparam();
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string TargetMethodCall = 10;
inline bool SuwayyahEvents_Suwayyah::has_targetmethodcall() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_targetmethodcall() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_targetmethodcall() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SuwayyahEvents_Suwayyah::clear_targetmethodcall() {
  if (targetmethodcall_ != &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_->clear();
  }
  clear_has_targetmethodcall();
}
inline const ::std::string& SuwayyahEvents_Suwayyah::targetmethodcall() const {
  return *targetmethodcall_;
}
inline void SuwayyahEvents_Suwayyah::set_targetmethodcall(const ::std::string& value) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_targetmethodcall(const char* value) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_targetmethodcall(const char* value, size_t size) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SuwayyahEvents_Suwayyah::mutable_targetmethodcall() {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  return targetmethodcall_;
}
inline ::std::string* SuwayyahEvents_Suwayyah::release_targetmethodcall() {
  clear_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetmethodcall_;
    targetmethodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SuwayyahEvents_Suwayyah::set_allocated_targetmethodcall(::std::string* targetmethodcall) {
  if (targetmethodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete targetmethodcall_;
  }
  if (targetmethodcall) {
    set_has_targetmethodcall();
    targetmethodcall_ = targetmethodcall;
  } else {
    clear_has_targetmethodcall();
    targetmethodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string TargetMethodParam = 11;
inline bool SuwayyahEvents_Suwayyah::has_targetmethodparam() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SuwayyahEvents_Suwayyah::set_has_targetmethodparam() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SuwayyahEvents_Suwayyah::clear_has_targetmethodparam() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SuwayyahEvents_Suwayyah::clear_targetmethodparam() {
  if (targetmethodparam_ != &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_->clear();
  }
  clear_has_targetmethodparam();
}
inline const ::std::string& SuwayyahEvents_Suwayyah::targetmethodparam() const {
  return *targetmethodparam_;
}
inline void SuwayyahEvents_Suwayyah::set_targetmethodparam(const ::std::string& value) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_targetmethodparam(const char* value) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(value);
}
inline void SuwayyahEvents_Suwayyah::set_targetmethodparam(const char* value, size_t size) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SuwayyahEvents_Suwayyah::mutable_targetmethodparam() {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  return targetmethodparam_;
}
inline ::std::string* SuwayyahEvents_Suwayyah::release_targetmethodparam() {
  clear_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetmethodparam_;
    targetmethodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SuwayyahEvents_Suwayyah::set_allocated_targetmethodparam(::std::string* targetmethodparam) {
  if (targetmethodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete targetmethodparam_;
  }
  if (targetmethodparam) {
    set_has_targetmethodparam();
    targetmethodparam_ = targetmethodparam;
  } else {
    clear_has_targetmethodparam();
    targetmethodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SuwayyahEvents

// repeated .NFFS.SuwayyahEvents.Suwayyah xSuwayyahList = 1;
inline int SuwayyahEvents::xsuwayyahlist_size() const {
  return xsuwayyahlist_.size();
}
inline void SuwayyahEvents::clear_xsuwayyahlist() {
  xsuwayyahlist_.Clear();
}
inline const ::NFFS::SuwayyahEvents_Suwayyah& SuwayyahEvents::xsuwayyahlist(int index) const {
  return xsuwayyahlist_.Get(index);
}
inline ::NFFS::SuwayyahEvents_Suwayyah* SuwayyahEvents::mutable_xsuwayyahlist(int index) {
  return xsuwayyahlist_.Mutable(index);
}
inline ::NFFS::SuwayyahEvents_Suwayyah* SuwayyahEvents::add_xsuwayyahlist() {
  return xsuwayyahlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::SuwayyahEvents_Suwayyah >&
SuwayyahEvents::xsuwayyahlist() const {
  return xsuwayyahlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::SuwayyahEvents_Suwayyah >*
SuwayyahEvents::mutable_xsuwayyahlist() {
  return &xsuwayyahlist_;
}

// -------------------------------------------------------------------

// BulletEvents_TacheBomp

// required float BompTime = 1;
inline bool BulletEvents_TacheBomp::has_bomptime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_bomptime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BulletEvents_TacheBomp::clear_has_bomptime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BulletEvents_TacheBomp::clear_bomptime() {
  bomptime_ = 0;
  clear_has_bomptime();
}
inline float BulletEvents_TacheBomp::bomptime() const {
  return bomptime_;
}
inline void BulletEvents_TacheBomp::set_bomptime(float value) {
  set_has_bomptime();
  bomptime_ = value;
}

// required float BompRang = 2;
inline bool BulletEvents_TacheBomp::has_bomprang() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_bomprang() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BulletEvents_TacheBomp::clear_has_bomprang() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BulletEvents_TacheBomp::clear_bomprang() {
  bomprang_ = 0;
  clear_has_bomprang();
}
inline float BulletEvents_TacheBomp::bomprang() const {
  return bomprang_;
}
inline void BulletEvents_TacheBomp::set_bomprang(float value) {
  set_has_bomprang();
  bomprang_ = value;
}

// required string BompPrefabPath = 3;
inline bool BulletEvents_TacheBomp::has_bompprefabpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_bompprefabpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BulletEvents_TacheBomp::clear_has_bompprefabpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BulletEvents_TacheBomp::clear_bompprefabpath() {
  if (bompprefabpath_ != &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_->clear();
  }
  clear_has_bompprefabpath();
}
inline const ::std::string& BulletEvents_TacheBomp::bompprefabpath() const {
  return *bompprefabpath_;
}
inline void BulletEvents_TacheBomp::set_bompprefabpath(const ::std::string& value) {
  set_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_ = new ::std::string;
  }
  bompprefabpath_->assign(value);
}
inline void BulletEvents_TacheBomp::set_bompprefabpath(const char* value) {
  set_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_ = new ::std::string;
  }
  bompprefabpath_->assign(value);
}
inline void BulletEvents_TacheBomp::set_bompprefabpath(const char* value, size_t size) {
  set_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_ = new ::std::string;
  }
  bompprefabpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_TacheBomp::mutable_bompprefabpath() {
  set_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bompprefabpath_ = new ::std::string;
  }
  return bompprefabpath_;
}
inline ::std::string* BulletEvents_TacheBomp::release_bompprefabpath() {
  clear_has_bompprefabpath();
  if (bompprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bompprefabpath_;
    bompprefabpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_TacheBomp::set_allocated_bompprefabpath(::std::string* bompprefabpath) {
  if (bompprefabpath_ != &::google::protobuf::internal::kEmptyString) {
    delete bompprefabpath_;
  }
  if (bompprefabpath) {
    set_has_bompprefabpath();
    bompprefabpath_ = bompprefabpath;
  } else {
    clear_has_bompprefabpath();
    bompprefabpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string BeAttackParticle = 4;
inline bool BulletEvents_TacheBomp::has_beattackparticle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_beattackparticle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BulletEvents_TacheBomp::clear_has_beattackparticle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BulletEvents_TacheBomp::clear_beattackparticle() {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    beattackparticle_->clear();
  }
  clear_has_beattackparticle();
}
inline const ::std::string& BulletEvents_TacheBomp::beattackparticle() const {
  return *beattackparticle_;
}
inline void BulletEvents_TacheBomp::set_beattackparticle(const ::std::string& value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void BulletEvents_TacheBomp::set_beattackparticle(const char* value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void BulletEvents_TacheBomp::set_beattackparticle(const char* value, size_t size) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_TacheBomp::mutable_beattackparticle() {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  return beattackparticle_;
}
inline ::std::string* BulletEvents_TacheBomp::release_beattackparticle() {
  clear_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beattackparticle_;
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_TacheBomp::set_allocated_beattackparticle(::std::string* beattackparticle) {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    delete beattackparticle_;
  }
  if (beattackparticle) {
    set_has_beattackparticle();
    beattackparticle_ = beattackparticle;
  } else {
    clear_has_beattackparticle();
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float BackNpcDis = 5;
inline bool BulletEvents_TacheBomp::has_backnpcdis() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_backnpcdis() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BulletEvents_TacheBomp::clear_has_backnpcdis() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BulletEvents_TacheBomp::clear_backnpcdis() {
  backnpcdis_ = 0;
  clear_has_backnpcdis();
}
inline float BulletEvents_TacheBomp::backnpcdis() const {
  return backnpcdis_;
}
inline void BulletEvents_TacheBomp::set_backnpcdis(float value) {
  set_has_backnpcdis();
  backnpcdis_ = value;
}

// required float BackHeroDis = 6;
inline bool BulletEvents_TacheBomp::has_backherodis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_backherodis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BulletEvents_TacheBomp::clear_has_backherodis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BulletEvents_TacheBomp::clear_backherodis() {
  backherodis_ = 0;
  clear_has_backherodis();
}
inline float BulletEvents_TacheBomp::backherodis() const {
  return backherodis_;
}
inline void BulletEvents_TacheBomp::set_backherodis(float value) {
  set_has_backherodis();
  backherodis_ = value;
}

// required string MethodCall = 7;
inline bool BulletEvents_TacheBomp::has_methodcall() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_methodcall() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BulletEvents_TacheBomp::clear_has_methodcall() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BulletEvents_TacheBomp::clear_methodcall() {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    methodcall_->clear();
  }
  clear_has_methodcall();
}
inline const ::std::string& BulletEvents_TacheBomp::methodcall() const {
  return *methodcall_;
}
inline void BulletEvents_TacheBomp::set_methodcall(const ::std::string& value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void BulletEvents_TacheBomp::set_methodcall(const char* value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void BulletEvents_TacheBomp::set_methodcall(const char* value, size_t size) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_TacheBomp::mutable_methodcall() {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  return methodcall_;
}
inline ::std::string* BulletEvents_TacheBomp::release_methodcall() {
  clear_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodcall_;
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_TacheBomp::set_allocated_methodcall(::std::string* methodcall) {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete methodcall_;
  }
  if (methodcall) {
    set_has_methodcall();
    methodcall_ = methodcall;
  } else {
    clear_has_methodcall();
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodParam = 8;
inline bool BulletEvents_TacheBomp::has_methodparam() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_methodparam() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BulletEvents_TacheBomp::clear_has_methodparam() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BulletEvents_TacheBomp::clear_methodparam() {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    methodparam_->clear();
  }
  clear_has_methodparam();
}
inline const ::std::string& BulletEvents_TacheBomp::methodparam() const {
  return *methodparam_;
}
inline void BulletEvents_TacheBomp::set_methodparam(const ::std::string& value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void BulletEvents_TacheBomp::set_methodparam(const char* value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void BulletEvents_TacheBomp::set_methodparam(const char* value, size_t size) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_TacheBomp::mutable_methodparam() {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  return methodparam_;
}
inline ::std::string* BulletEvents_TacheBomp::release_methodparam() {
  clear_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodparam_;
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_TacheBomp::set_allocated_methodparam(::std::string* methodparam) {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete methodparam_;
  }
  if (methodparam) {
    set_has_methodparam();
    methodparam_ = methodparam;
  } else {
    clear_has_methodparam();
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string TargetMethodCall = 9;
inline bool BulletEvents_TacheBomp::has_targetmethodcall() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_targetmethodcall() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BulletEvents_TacheBomp::clear_has_targetmethodcall() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BulletEvents_TacheBomp::clear_targetmethodcall() {
  if (targetmethodcall_ != &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_->clear();
  }
  clear_has_targetmethodcall();
}
inline const ::std::string& BulletEvents_TacheBomp::targetmethodcall() const {
  return *targetmethodcall_;
}
inline void BulletEvents_TacheBomp::set_targetmethodcall(const ::std::string& value) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(value);
}
inline void BulletEvents_TacheBomp::set_targetmethodcall(const char* value) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(value);
}
inline void BulletEvents_TacheBomp::set_targetmethodcall(const char* value, size_t size) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_TacheBomp::mutable_targetmethodcall() {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  return targetmethodcall_;
}
inline ::std::string* BulletEvents_TacheBomp::release_targetmethodcall() {
  clear_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetmethodcall_;
    targetmethodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_TacheBomp::set_allocated_targetmethodcall(::std::string* targetmethodcall) {
  if (targetmethodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete targetmethodcall_;
  }
  if (targetmethodcall) {
    set_has_targetmethodcall();
    targetmethodcall_ = targetmethodcall;
  } else {
    clear_has_targetmethodcall();
    targetmethodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string TargetMethodParam = 10;
inline bool BulletEvents_TacheBomp::has_targetmethodparam() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BulletEvents_TacheBomp::set_has_targetmethodparam() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BulletEvents_TacheBomp::clear_has_targetmethodparam() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BulletEvents_TacheBomp::clear_targetmethodparam() {
  if (targetmethodparam_ != &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_->clear();
  }
  clear_has_targetmethodparam();
}
inline const ::std::string& BulletEvents_TacheBomp::targetmethodparam() const {
  return *targetmethodparam_;
}
inline void BulletEvents_TacheBomp::set_targetmethodparam(const ::std::string& value) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(value);
}
inline void BulletEvents_TacheBomp::set_targetmethodparam(const char* value) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(value);
}
inline void BulletEvents_TacheBomp::set_targetmethodparam(const char* value, size_t size) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_TacheBomp::mutable_targetmethodparam() {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  return targetmethodparam_;
}
inline ::std::string* BulletEvents_TacheBomp::release_targetmethodparam() {
  clear_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetmethodparam_;
    targetmethodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_TacheBomp::set_allocated_targetmethodparam(::std::string* targetmethodparam) {
  if (targetmethodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete targetmethodparam_;
  }
  if (targetmethodparam) {
    set_has_targetmethodparam();
    targetmethodparam_ = targetmethodparam;
  } else {
    clear_has_targetmethodparam();
    targetmethodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BulletEvents_Bullet

// required float EventTime = 1;
inline bool BulletEvents_Bullet::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulletEvents_Bullet::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BulletEvents_Bullet::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BulletEvents_Bullet::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float BulletEvents_Bullet::eventtime() const {
  return eventtime_;
}
inline void BulletEvents_Bullet::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.BulletEvents.EBEType EventType = 2;
inline bool BulletEvents_Bullet::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BulletEvents_Bullet::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BulletEvents_Bullet::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BulletEvents_Bullet::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::BulletEvents_EBEType BulletEvents_Bullet::eventtype() const {
  return static_cast< ::NFFS::BulletEvents_EBEType >(eventtype_);
}
inline void BulletEvents_Bullet::set_eventtype(::NFFS::BulletEvents_EBEType value) {
  assert(::NFFS::BulletEvents_EBEType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required float Speed = 3;
inline bool BulletEvents_Bullet::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BulletEvents_Bullet::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BulletEvents_Bullet::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BulletEvents_Bullet::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float BulletEvents_Bullet::speed() const {
  return speed_;
}
inline void BulletEvents_Bullet::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// required float MaxDis = 4;
inline bool BulletEvents_Bullet::has_maxdis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BulletEvents_Bullet::set_has_maxdis() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BulletEvents_Bullet::clear_has_maxdis() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BulletEvents_Bullet::clear_maxdis() {
  maxdis_ = 0;
  clear_has_maxdis();
}
inline float BulletEvents_Bullet::maxdis() const {
  return maxdis_;
}
inline void BulletEvents_Bullet::set_maxdis(float value) {
  set_has_maxdis();
  maxdis_ = value;
}

// required float BulletRang = 5;
inline bool BulletEvents_Bullet::has_bulletrang() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BulletEvents_Bullet::set_has_bulletrang() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BulletEvents_Bullet::clear_has_bulletrang() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BulletEvents_Bullet::clear_bulletrang() {
  bulletrang_ = 0;
  clear_has_bulletrang();
}
inline float BulletEvents_Bullet::bulletrang() const {
  return bulletrang_;
}
inline void BulletEvents_Bullet::set_bulletrang(float value) {
  set_has_bulletrang();
  bulletrang_ = value;
}

// required .NFFS.BulletEvents.EBE_BACKType BulletBackType = 6;
inline bool BulletEvents_Bullet::has_bulletbacktype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BulletEvents_Bullet::set_has_bulletbacktype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BulletEvents_Bullet::clear_has_bulletbacktype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BulletEvents_Bullet::clear_bulletbacktype() {
  bulletbacktype_ = 0;
  clear_has_bulletbacktype();
}
inline ::NFFS::BulletEvents_EBE_BACKType BulletEvents_Bullet::bulletbacktype() const {
  return static_cast< ::NFFS::BulletEvents_EBE_BACKType >(bulletbacktype_);
}
inline void BulletEvents_Bullet::set_bulletbacktype(::NFFS::BulletEvents_EBE_BACKType value) {
  assert(::NFFS::BulletEvents_EBE_BACKType_IsValid(value));
  set_has_bulletbacktype();
  bulletbacktype_ = value;
}

// required float BackHeroDis = 7;
inline bool BulletEvents_Bullet::has_backherodis() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BulletEvents_Bullet::set_has_backherodis() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BulletEvents_Bullet::clear_has_backherodis() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BulletEvents_Bullet::clear_backherodis() {
  backherodis_ = 0;
  clear_has_backherodis();
}
inline float BulletEvents_Bullet::backherodis() const {
  return backherodis_;
}
inline void BulletEvents_Bullet::set_backherodis(float value) {
  set_has_backherodis();
  backherodis_ = value;
}

// required float BackNpcDis = 8;
inline bool BulletEvents_Bullet::has_backnpcdis() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BulletEvents_Bullet::set_has_backnpcdis() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BulletEvents_Bullet::clear_has_backnpcdis() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BulletEvents_Bullet::clear_backnpcdis() {
  backnpcdis_ = 0;
  clear_has_backnpcdis();
}
inline float BulletEvents_Bullet::backnpcdis() const {
  return backnpcdis_;
}
inline void BulletEvents_Bullet::set_backnpcdis(float value) {
  set_has_backnpcdis();
  backnpcdis_ = value;
}

// required int32 TacheDetroy = 9;
inline bool BulletEvents_Bullet::has_tachedetroy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BulletEvents_Bullet::set_has_tachedetroy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BulletEvents_Bullet::clear_has_tachedetroy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BulletEvents_Bullet::clear_tachedetroy() {
  tachedetroy_ = 0;
  clear_has_tachedetroy();
}
inline ::google::protobuf::int32 BulletEvents_Bullet::tachedetroy() const {
  return tachedetroy_;
}
inline void BulletEvents_Bullet::set_tachedetroy(::google::protobuf::int32 value) {
  set_has_tachedetroy();
  tachedetroy_ = value;
}

// required string BeAttackParticle = 10;
inline bool BulletEvents_Bullet::has_beattackparticle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BulletEvents_Bullet::set_has_beattackparticle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BulletEvents_Bullet::clear_has_beattackparticle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BulletEvents_Bullet::clear_beattackparticle() {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    beattackparticle_->clear();
  }
  clear_has_beattackparticle();
}
inline const ::std::string& BulletEvents_Bullet::beattackparticle() const {
  return *beattackparticle_;
}
inline void BulletEvents_Bullet::set_beattackparticle(const ::std::string& value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void BulletEvents_Bullet::set_beattackparticle(const char* value) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(value);
}
inline void BulletEvents_Bullet::set_beattackparticle(const char* value, size_t size) {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  beattackparticle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_Bullet::mutable_beattackparticle() {
  set_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    beattackparticle_ = new ::std::string;
  }
  return beattackparticle_;
}
inline ::std::string* BulletEvents_Bullet::release_beattackparticle() {
  clear_has_beattackparticle();
  if (beattackparticle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beattackparticle_;
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_Bullet::set_allocated_beattackparticle(::std::string* beattackparticle) {
  if (beattackparticle_ != &::google::protobuf::internal::kEmptyString) {
    delete beattackparticle_;
  }
  if (beattackparticle) {
    set_has_beattackparticle();
    beattackparticle_ = beattackparticle;
  } else {
    clear_has_beattackparticle();
    beattackparticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FireTacheName = 11;
inline bool BulletEvents_Bullet::has_firetachename() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BulletEvents_Bullet::set_has_firetachename() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BulletEvents_Bullet::clear_has_firetachename() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BulletEvents_Bullet::clear_firetachename() {
  if (firetachename_ != &::google::protobuf::internal::kEmptyString) {
    firetachename_->clear();
  }
  clear_has_firetachename();
}
inline const ::std::string& BulletEvents_Bullet::firetachename() const {
  return *firetachename_;
}
inline void BulletEvents_Bullet::set_firetachename(const ::std::string& value) {
  set_has_firetachename();
  if (firetachename_ == &::google::protobuf::internal::kEmptyString) {
    firetachename_ = new ::std::string;
  }
  firetachename_->assign(value);
}
inline void BulletEvents_Bullet::set_firetachename(const char* value) {
  set_has_firetachename();
  if (firetachename_ == &::google::protobuf::internal::kEmptyString) {
    firetachename_ = new ::std::string;
  }
  firetachename_->assign(value);
}
inline void BulletEvents_Bullet::set_firetachename(const char* value, size_t size) {
  set_has_firetachename();
  if (firetachename_ == &::google::protobuf::internal::kEmptyString) {
    firetachename_ = new ::std::string;
  }
  firetachename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_Bullet::mutable_firetachename() {
  set_has_firetachename();
  if (firetachename_ == &::google::protobuf::internal::kEmptyString) {
    firetachename_ = new ::std::string;
  }
  return firetachename_;
}
inline ::std::string* BulletEvents_Bullet::release_firetachename() {
  clear_has_firetachename();
  if (firetachename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firetachename_;
    firetachename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_Bullet::set_allocated_firetachename(::std::string* firetachename) {
  if (firetachename_ != &::google::protobuf::internal::kEmptyString) {
    delete firetachename_;
  }
  if (firetachename) {
    set_has_firetachename();
    firetachename_ = firetachename;
  } else {
    clear_has_firetachename();
    firetachename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .NFFS.FSVector3 FireTacheOffest = 12;
inline bool BulletEvents_Bullet::has_firetacheoffest() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BulletEvents_Bullet::set_has_firetacheoffest() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BulletEvents_Bullet::clear_has_firetacheoffest() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BulletEvents_Bullet::clear_firetacheoffest() {
  if (firetacheoffest_ != NULL) firetacheoffest_->::NFFS::FSVector3::Clear();
  clear_has_firetacheoffest();
}
inline const ::NFFS::FSVector3& BulletEvents_Bullet::firetacheoffest() const {
  return firetacheoffest_ != NULL ? *firetacheoffest_ : *default_instance_->firetacheoffest_;
}
inline ::NFFS::FSVector3* BulletEvents_Bullet::mutable_firetacheoffest() {
  set_has_firetacheoffest();
  if (firetacheoffest_ == NULL) firetacheoffest_ = new ::NFFS::FSVector3;
  return firetacheoffest_;
}
inline ::NFFS::FSVector3* BulletEvents_Bullet::release_firetacheoffest() {
  clear_has_firetacheoffest();
  ::NFFS::FSVector3* temp = firetacheoffest_;
  firetacheoffest_ = NULL;
  return temp;
}
inline void BulletEvents_Bullet::set_allocated_firetacheoffest(::NFFS::FSVector3* firetacheoffest) {
  delete firetacheoffest_;
  firetacheoffest_ = firetacheoffest;
  if (firetacheoffest) {
    set_has_firetacheoffest();
  } else {
    clear_has_firetacheoffest();
  }
}

// required string BulletPrefabPath = 13;
inline bool BulletEvents_Bullet::has_bulletprefabpath() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BulletEvents_Bullet::set_has_bulletprefabpath() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BulletEvents_Bullet::clear_has_bulletprefabpath() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BulletEvents_Bullet::clear_bulletprefabpath() {
  if (bulletprefabpath_ != &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_->clear();
  }
  clear_has_bulletprefabpath();
}
inline const ::std::string& BulletEvents_Bullet::bulletprefabpath() const {
  return *bulletprefabpath_;
}
inline void BulletEvents_Bullet::set_bulletprefabpath(const ::std::string& value) {
  set_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_ = new ::std::string;
  }
  bulletprefabpath_->assign(value);
}
inline void BulletEvents_Bullet::set_bulletprefabpath(const char* value) {
  set_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_ = new ::std::string;
  }
  bulletprefabpath_->assign(value);
}
inline void BulletEvents_Bullet::set_bulletprefabpath(const char* value, size_t size) {
  set_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_ = new ::std::string;
  }
  bulletprefabpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_Bullet::mutable_bulletprefabpath() {
  set_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    bulletprefabpath_ = new ::std::string;
  }
  return bulletprefabpath_;
}
inline ::std::string* BulletEvents_Bullet::release_bulletprefabpath() {
  clear_has_bulletprefabpath();
  if (bulletprefabpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bulletprefabpath_;
    bulletprefabpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_Bullet::set_allocated_bulletprefabpath(::std::string* bulletprefabpath) {
  if (bulletprefabpath_ != &::google::protobuf::internal::kEmptyString) {
    delete bulletprefabpath_;
  }
  if (bulletprefabpath) {
    set_has_bulletprefabpath();
    bulletprefabpath_ = bulletprefabpath;
  } else {
    clear_has_bulletprefabpath();
    bulletprefabpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodCall = 14;
inline bool BulletEvents_Bullet::has_methodcall() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BulletEvents_Bullet::set_has_methodcall() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BulletEvents_Bullet::clear_has_methodcall() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BulletEvents_Bullet::clear_methodcall() {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    methodcall_->clear();
  }
  clear_has_methodcall();
}
inline const ::std::string& BulletEvents_Bullet::methodcall() const {
  return *methodcall_;
}
inline void BulletEvents_Bullet::set_methodcall(const ::std::string& value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void BulletEvents_Bullet::set_methodcall(const char* value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void BulletEvents_Bullet::set_methodcall(const char* value, size_t size) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_Bullet::mutable_methodcall() {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  return methodcall_;
}
inline ::std::string* BulletEvents_Bullet::release_methodcall() {
  clear_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodcall_;
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_Bullet::set_allocated_methodcall(::std::string* methodcall) {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete methodcall_;
  }
  if (methodcall) {
    set_has_methodcall();
    methodcall_ = methodcall;
  } else {
    clear_has_methodcall();
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodParam = 15;
inline bool BulletEvents_Bullet::has_methodparam() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BulletEvents_Bullet::set_has_methodparam() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BulletEvents_Bullet::clear_has_methodparam() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BulletEvents_Bullet::clear_methodparam() {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    methodparam_->clear();
  }
  clear_has_methodparam();
}
inline const ::std::string& BulletEvents_Bullet::methodparam() const {
  return *methodparam_;
}
inline void BulletEvents_Bullet::set_methodparam(const ::std::string& value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void BulletEvents_Bullet::set_methodparam(const char* value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void BulletEvents_Bullet::set_methodparam(const char* value, size_t size) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_Bullet::mutable_methodparam() {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  return methodparam_;
}
inline ::std::string* BulletEvents_Bullet::release_methodparam() {
  clear_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodparam_;
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_Bullet::set_allocated_methodparam(::std::string* methodparam) {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete methodparam_;
  }
  if (methodparam) {
    set_has_methodparam();
    methodparam_ = methodparam;
  } else {
    clear_has_methodparam();
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string TargetMethodCall = 16;
inline bool BulletEvents_Bullet::has_targetmethodcall() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BulletEvents_Bullet::set_has_targetmethodcall() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BulletEvents_Bullet::clear_has_targetmethodcall() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BulletEvents_Bullet::clear_targetmethodcall() {
  if (targetmethodcall_ != &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_->clear();
  }
  clear_has_targetmethodcall();
}
inline const ::std::string& BulletEvents_Bullet::targetmethodcall() const {
  return *targetmethodcall_;
}
inline void BulletEvents_Bullet::set_targetmethodcall(const ::std::string& value) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(value);
}
inline void BulletEvents_Bullet::set_targetmethodcall(const char* value) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(value);
}
inline void BulletEvents_Bullet::set_targetmethodcall(const char* value, size_t size) {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  targetmethodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_Bullet::mutable_targetmethodcall() {
  set_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodcall_ = new ::std::string;
  }
  return targetmethodcall_;
}
inline ::std::string* BulletEvents_Bullet::release_targetmethodcall() {
  clear_has_targetmethodcall();
  if (targetmethodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetmethodcall_;
    targetmethodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_Bullet::set_allocated_targetmethodcall(::std::string* targetmethodcall) {
  if (targetmethodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete targetmethodcall_;
  }
  if (targetmethodcall) {
    set_has_targetmethodcall();
    targetmethodcall_ = targetmethodcall;
  } else {
    clear_has_targetmethodcall();
    targetmethodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string TargetMethodParam = 17;
inline bool BulletEvents_Bullet::has_targetmethodparam() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BulletEvents_Bullet::set_has_targetmethodparam() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BulletEvents_Bullet::clear_has_targetmethodparam() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BulletEvents_Bullet::clear_targetmethodparam() {
  if (targetmethodparam_ != &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_->clear();
  }
  clear_has_targetmethodparam();
}
inline const ::std::string& BulletEvents_Bullet::targetmethodparam() const {
  return *targetmethodparam_;
}
inline void BulletEvents_Bullet::set_targetmethodparam(const ::std::string& value) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(value);
}
inline void BulletEvents_Bullet::set_targetmethodparam(const char* value) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(value);
}
inline void BulletEvents_Bullet::set_targetmethodparam(const char* value, size_t size) {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  targetmethodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BulletEvents_Bullet::mutable_targetmethodparam() {
  set_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    targetmethodparam_ = new ::std::string;
  }
  return targetmethodparam_;
}
inline ::std::string* BulletEvents_Bullet::release_targetmethodparam() {
  clear_has_targetmethodparam();
  if (targetmethodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetmethodparam_;
    targetmethodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BulletEvents_Bullet::set_allocated_targetmethodparam(::std::string* targetmethodparam) {
  if (targetmethodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete targetmethodparam_;
  }
  if (targetmethodparam) {
    set_has_targetmethodparam();
    targetmethodparam_ = targetmethodparam;
  } else {
    clear_has_targetmethodparam();
    targetmethodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .NFFS.BulletEvents.TacheBomp Bomp = 18;
inline int BulletEvents_Bullet::bomp_size() const {
  return bomp_.size();
}
inline void BulletEvents_Bullet::clear_bomp() {
  bomp_.Clear();
}
inline const ::NFFS::BulletEvents_TacheBomp& BulletEvents_Bullet::bomp(int index) const {
  return bomp_.Get(index);
}
inline ::NFFS::BulletEvents_TacheBomp* BulletEvents_Bullet::mutable_bomp(int index) {
  return bomp_.Mutable(index);
}
inline ::NFFS::BulletEvents_TacheBomp* BulletEvents_Bullet::add_bomp() {
  return bomp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_TacheBomp >&
BulletEvents_Bullet::bomp() const {
  return bomp_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_TacheBomp >*
BulletEvents_Bullet::mutable_bomp() {
  return &bomp_;
}

// -------------------------------------------------------------------

// BulletEvents

// repeated .NFFS.BulletEvents.Bullet xBulletList = 1;
inline int BulletEvents::xbulletlist_size() const {
  return xbulletlist_.size();
}
inline void BulletEvents::clear_xbulletlist() {
  xbulletlist_.Clear();
}
inline const ::NFFS::BulletEvents_Bullet& BulletEvents::xbulletlist(int index) const {
  return xbulletlist_.Get(index);
}
inline ::NFFS::BulletEvents_Bullet* BulletEvents::mutable_xbulletlist(int index) {
  return xbulletlist_.Mutable(index);
}
inline ::NFFS::BulletEvents_Bullet* BulletEvents::add_xbulletlist() {
  return xbulletlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_Bullet >&
BulletEvents::xbulletlist() const {
  return xbulletlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::BulletEvents_Bullet >*
BulletEvents::mutable_xbulletlist() {
  return &xbulletlist_;
}

// -------------------------------------------------------------------

// AnimatorMoves_Move

// required float EventTime = 1;
inline bool AnimatorMoves_Move::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnimatorMoves_Move::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnimatorMoves_Move::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnimatorMoves_Move::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float AnimatorMoves_Move::eventtime() const {
  return eventtime_;
}
inline void AnimatorMoves_Move::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.AnimatorMoves.EAMType EventType = 2;
inline bool AnimatorMoves_Move::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnimatorMoves_Move::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnimatorMoves_Move::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnimatorMoves_Move::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::AnimatorMoves_EAMType AnimatorMoves_Move::eventtype() const {
  return static_cast< ::NFFS::AnimatorMoves_EAMType >(eventtype_);
}
inline void AnimatorMoves_Move::set_eventtype(::NFFS::AnimatorMoves_EAMType value) {
  assert(::NFFS::AnimatorMoves_EAMType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required float MoveDis = 3;
inline bool AnimatorMoves_Move::has_movedis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnimatorMoves_Move::set_has_movedis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnimatorMoves_Move::clear_has_movedis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnimatorMoves_Move::clear_movedis() {
  movedis_ = 0;
  clear_has_movedis();
}
inline float AnimatorMoves_Move::movedis() const {
  return movedis_;
}
inline void AnimatorMoves_Move::set_movedis(float value) {
  set_has_movedis();
  movedis_ = value;
}

// required float MoveTime = 4;
inline bool AnimatorMoves_Move::has_movetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnimatorMoves_Move::set_has_movetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnimatorMoves_Move::clear_has_movetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnimatorMoves_Move::clear_movetime() {
  movetime_ = 0;
  clear_has_movetime();
}
inline float AnimatorMoves_Move::movetime() const {
  return movetime_;
}
inline void AnimatorMoves_Move::set_movetime(float value) {
  set_has_movetime();
  movetime_ = value;
}

// required string MethodCall = 5;
inline bool AnimatorMoves_Move::has_methodcall() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnimatorMoves_Move::set_has_methodcall() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnimatorMoves_Move::clear_has_methodcall() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnimatorMoves_Move::clear_methodcall() {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    methodcall_->clear();
  }
  clear_has_methodcall();
}
inline const ::std::string& AnimatorMoves_Move::methodcall() const {
  return *methodcall_;
}
inline void AnimatorMoves_Move::set_methodcall(const ::std::string& value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void AnimatorMoves_Move::set_methodcall(const char* value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void AnimatorMoves_Move::set_methodcall(const char* value, size_t size) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimatorMoves_Move::mutable_methodcall() {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  return methodcall_;
}
inline ::std::string* AnimatorMoves_Move::release_methodcall() {
  clear_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodcall_;
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AnimatorMoves_Move::set_allocated_methodcall(::std::string* methodcall) {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete methodcall_;
  }
  if (methodcall) {
    set_has_methodcall();
    methodcall_ = methodcall;
  } else {
    clear_has_methodcall();
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodParam = 6;
inline bool AnimatorMoves_Move::has_methodparam() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnimatorMoves_Move::set_has_methodparam() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnimatorMoves_Move::clear_has_methodparam() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnimatorMoves_Move::clear_methodparam() {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    methodparam_->clear();
  }
  clear_has_methodparam();
}
inline const ::std::string& AnimatorMoves_Move::methodparam() const {
  return *methodparam_;
}
inline void AnimatorMoves_Move::set_methodparam(const ::std::string& value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void AnimatorMoves_Move::set_methodparam(const char* value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void AnimatorMoves_Move::set_methodparam(const char* value, size_t size) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnimatorMoves_Move::mutable_methodparam() {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  return methodparam_;
}
inline ::std::string* AnimatorMoves_Move::release_methodparam() {
  clear_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodparam_;
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AnimatorMoves_Move::set_allocated_methodparam(::std::string* methodparam) {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete methodparam_;
  }
  if (methodparam) {
    set_has_methodparam();
    methodparam_ = methodparam;
  } else {
    clear_has_methodparam();
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AnimatorMoves

// repeated .NFFS.AnimatorMoves.Move xMoveList = 1;
inline int AnimatorMoves::xmovelist_size() const {
  return xmovelist_.size();
}
inline void AnimatorMoves::clear_xmovelist() {
  xmovelist_.Clear();
}
inline const ::NFFS::AnimatorMoves_Move& AnimatorMoves::xmovelist(int index) const {
  return xmovelist_.Get(index);
}
inline ::NFFS::AnimatorMoves_Move* AnimatorMoves::mutable_xmovelist(int index) {
  return xmovelist_.Mutable(index);
}
inline ::NFFS::AnimatorMoves_Move* AnimatorMoves::add_xmovelist() {
  return xmovelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::AnimatorMoves_Move >&
AnimatorMoves::xmovelist() const {
  return xmovelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::AnimatorMoves_Move >*
AnimatorMoves::mutable_xmovelist() {
  return &xmovelist_;
}

// -------------------------------------------------------------------

// CameraControlEvents_Camera

// required float EventTime = 1;
inline bool CameraControlEvents_Camera::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraControlEvents_Camera::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraControlEvents_Camera::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraControlEvents_Camera::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float CameraControlEvents_Camera::eventtime() const {
  return eventtime_;
}
inline void CameraControlEvents_Camera::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.CameraControlEvents.ECEType EventType = 2;
inline bool CameraControlEvents_Camera::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraControlEvents_Camera::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraControlEvents_Camera::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraControlEvents_Camera::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::CameraControlEvents_ECEType CameraControlEvents_Camera::eventtype() const {
  return static_cast< ::NFFS::CameraControlEvents_ECEType >(eventtype_);
}
inline void CameraControlEvents_Camera::set_eventtype(::NFFS::CameraControlEvents_ECEType value) {
  assert(::NFFS::CameraControlEvents_ECEType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required .NFFS.FSVector3 AmountParam = 3;
inline bool CameraControlEvents_Camera::has_amountparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraControlEvents_Camera::set_has_amountparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraControlEvents_Camera::clear_has_amountparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraControlEvents_Camera::clear_amountparam() {
  if (amountparam_ != NULL) amountparam_->::NFFS::FSVector3::Clear();
  clear_has_amountparam();
}
inline const ::NFFS::FSVector3& CameraControlEvents_Camera::amountparam() const {
  return amountparam_ != NULL ? *amountparam_ : *default_instance_->amountparam_;
}
inline ::NFFS::FSVector3* CameraControlEvents_Camera::mutable_amountparam() {
  set_has_amountparam();
  if (amountparam_ == NULL) amountparam_ = new ::NFFS::FSVector3;
  return amountparam_;
}
inline ::NFFS::FSVector3* CameraControlEvents_Camera::release_amountparam() {
  clear_has_amountparam();
  ::NFFS::FSVector3* temp = amountparam_;
  amountparam_ = NULL;
  return temp;
}
inline void CameraControlEvents_Camera::set_allocated_amountparam(::NFFS::FSVector3* amountparam) {
  delete amountparam_;
  amountparam_ = amountparam;
  if (amountparam) {
    set_has_amountparam();
  } else {
    clear_has_amountparam();
  }
}

// required float ShakeTime = 4;
inline bool CameraControlEvents_Camera::has_shaketime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraControlEvents_Camera::set_has_shaketime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraControlEvents_Camera::clear_has_shaketime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraControlEvents_Camera::clear_shaketime() {
  shaketime_ = 0;
  clear_has_shaketime();
}
inline float CameraControlEvents_Camera::shaketime() const {
  return shaketime_;
}
inline void CameraControlEvents_Camera::set_shaketime(float value) {
  set_has_shaketime();
  shaketime_ = value;
}

// required string MethodCall = 5;
inline bool CameraControlEvents_Camera::has_methodcall() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraControlEvents_Camera::set_has_methodcall() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraControlEvents_Camera::clear_has_methodcall() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraControlEvents_Camera::clear_methodcall() {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    methodcall_->clear();
  }
  clear_has_methodcall();
}
inline const ::std::string& CameraControlEvents_Camera::methodcall() const {
  return *methodcall_;
}
inline void CameraControlEvents_Camera::set_methodcall(const ::std::string& value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void CameraControlEvents_Camera::set_methodcall(const char* value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void CameraControlEvents_Camera::set_methodcall(const char* value, size_t size) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraControlEvents_Camera::mutable_methodcall() {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  return methodcall_;
}
inline ::std::string* CameraControlEvents_Camera::release_methodcall() {
  clear_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodcall_;
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CameraControlEvents_Camera::set_allocated_methodcall(::std::string* methodcall) {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete methodcall_;
  }
  if (methodcall) {
    set_has_methodcall();
    methodcall_ = methodcall;
  } else {
    clear_has_methodcall();
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodParam = 6;
inline bool CameraControlEvents_Camera::has_methodparam() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CameraControlEvents_Camera::set_has_methodparam() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CameraControlEvents_Camera::clear_has_methodparam() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CameraControlEvents_Camera::clear_methodparam() {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    methodparam_->clear();
  }
  clear_has_methodparam();
}
inline const ::std::string& CameraControlEvents_Camera::methodparam() const {
  return *methodparam_;
}
inline void CameraControlEvents_Camera::set_methodparam(const ::std::string& value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void CameraControlEvents_Camera::set_methodparam(const char* value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void CameraControlEvents_Camera::set_methodparam(const char* value, size_t size) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraControlEvents_Camera::mutable_methodparam() {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  return methodparam_;
}
inline ::std::string* CameraControlEvents_Camera::release_methodparam() {
  clear_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodparam_;
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CameraControlEvents_Camera::set_allocated_methodparam(::std::string* methodparam) {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete methodparam_;
  }
  if (methodparam) {
    set_has_methodparam();
    methodparam_ = methodparam;
  } else {
    clear_has_methodparam();
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CameraControlEvents

// repeated .NFFS.CameraControlEvents.Camera xCameraList = 1;
inline int CameraControlEvents::xcameralist_size() const {
  return xcameralist_.size();
}
inline void CameraControlEvents::clear_xcameralist() {
  xcameralist_.Clear();
}
inline const ::NFFS::CameraControlEvents_Camera& CameraControlEvents::xcameralist(int index) const {
  return xcameralist_.Get(index);
}
inline ::NFFS::CameraControlEvents_Camera* CameraControlEvents::mutable_xcameralist(int index) {
  return xcameralist_.Mutable(index);
}
inline ::NFFS::CameraControlEvents_Camera* CameraControlEvents::add_xcameralist() {
  return xcameralist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::CameraControlEvents_Camera >&
CameraControlEvents::xcameralist() const {
  return xcameralist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::CameraControlEvents_Camera >*
CameraControlEvents::mutable_xcameralist() {
  return &xcameralist_;
}

// -------------------------------------------------------------------

// ParticleEvents_Particle

// required float EventTime = 1;
inline bool ParticleEvents_Particle::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParticleEvents_Particle::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParticleEvents_Particle::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParticleEvents_Particle::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float ParticleEvents_Particle::eventtime() const {
  return eventtime_;
}
inline void ParticleEvents_Particle::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.ParticleEvents.EPERTYPE Rotation = 3;
inline bool ParticleEvents_Particle::has_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParticleEvents_Particle::set_has_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParticleEvents_Particle::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParticleEvents_Particle::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline ::NFFS::ParticleEvents_EPERTYPE ParticleEvents_Particle::rotation() const {
  return static_cast< ::NFFS::ParticleEvents_EPERTYPE >(rotation_);
}
inline void ParticleEvents_Particle::set_rotation(::NFFS::ParticleEvents_EPERTYPE value) {
  assert(::NFFS::ParticleEvents_EPERTYPE_IsValid(value));
  set_has_rotation();
  rotation_ = value;
}

// required string ParticlePath = 4;
inline bool ParticleEvents_Particle::has_particlepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParticleEvents_Particle::set_has_particlepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParticleEvents_Particle::clear_has_particlepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParticleEvents_Particle::clear_particlepath() {
  if (particlepath_ != &::google::protobuf::internal::kEmptyString) {
    particlepath_->clear();
  }
  clear_has_particlepath();
}
inline const ::std::string& ParticleEvents_Particle::particlepath() const {
  return *particlepath_;
}
inline void ParticleEvents_Particle::set_particlepath(const ::std::string& value) {
  set_has_particlepath();
  if (particlepath_ == &::google::protobuf::internal::kEmptyString) {
    particlepath_ = new ::std::string;
  }
  particlepath_->assign(value);
}
inline void ParticleEvents_Particle::set_particlepath(const char* value) {
  set_has_particlepath();
  if (particlepath_ == &::google::protobuf::internal::kEmptyString) {
    particlepath_ = new ::std::string;
  }
  particlepath_->assign(value);
}
inline void ParticleEvents_Particle::set_particlepath(const char* value, size_t size) {
  set_has_particlepath();
  if (particlepath_ == &::google::protobuf::internal::kEmptyString) {
    particlepath_ = new ::std::string;
  }
  particlepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParticleEvents_Particle::mutable_particlepath() {
  set_has_particlepath();
  if (particlepath_ == &::google::protobuf::internal::kEmptyString) {
    particlepath_ = new ::std::string;
  }
  return particlepath_;
}
inline ::std::string* ParticleEvents_Particle::release_particlepath() {
  clear_has_particlepath();
  if (particlepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = particlepath_;
    particlepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParticleEvents_Particle::set_allocated_particlepath(::std::string* particlepath) {
  if (particlepath_ != &::google::protobuf::internal::kEmptyString) {
    delete particlepath_;
  }
  if (particlepath) {
    set_has_particlepath();
    particlepath_ = particlepath;
  } else {
    clear_has_particlepath();
    particlepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string TargetTacheName = 5;
inline bool ParticleEvents_Particle::has_targettachename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParticleEvents_Particle::set_has_targettachename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParticleEvents_Particle::clear_has_targettachename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParticleEvents_Particle::clear_targettachename() {
  if (targettachename_ != &::google::protobuf::internal::kEmptyString) {
    targettachename_->clear();
  }
  clear_has_targettachename();
}
inline const ::std::string& ParticleEvents_Particle::targettachename() const {
  return *targettachename_;
}
inline void ParticleEvents_Particle::set_targettachename(const ::std::string& value) {
  set_has_targettachename();
  if (targettachename_ == &::google::protobuf::internal::kEmptyString) {
    targettachename_ = new ::std::string;
  }
  targettachename_->assign(value);
}
inline void ParticleEvents_Particle::set_targettachename(const char* value) {
  set_has_targettachename();
  if (targettachename_ == &::google::protobuf::internal::kEmptyString) {
    targettachename_ = new ::std::string;
  }
  targettachename_->assign(value);
}
inline void ParticleEvents_Particle::set_targettachename(const char* value, size_t size) {
  set_has_targettachename();
  if (targettachename_ == &::google::protobuf::internal::kEmptyString) {
    targettachename_ = new ::std::string;
  }
  targettachename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParticleEvents_Particle::mutable_targettachename() {
  set_has_targettachename();
  if (targettachename_ == &::google::protobuf::internal::kEmptyString) {
    targettachename_ = new ::std::string;
  }
  return targettachename_;
}
inline ::std::string* ParticleEvents_Particle::release_targettachename() {
  clear_has_targettachename();
  if (targettachename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targettachename_;
    targettachename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParticleEvents_Particle::set_allocated_targettachename(::std::string* targettachename) {
  if (targettachename_ != &::google::protobuf::internal::kEmptyString) {
    delete targettachename_;
  }
  if (targettachename) {
    set_has_targettachename();
    targettachename_ = targettachename;
  } else {
    clear_has_targettachename();
    targettachename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .NFFS.FSVector3 TargetTacheOffest = 6;
inline bool ParticleEvents_Particle::has_targettacheoffest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParticleEvents_Particle::set_has_targettacheoffest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParticleEvents_Particle::clear_has_targettacheoffest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParticleEvents_Particle::clear_targettacheoffest() {
  if (targettacheoffest_ != NULL) targettacheoffest_->::NFFS::FSVector3::Clear();
  clear_has_targettacheoffest();
}
inline const ::NFFS::FSVector3& ParticleEvents_Particle::targettacheoffest() const {
  return targettacheoffest_ != NULL ? *targettacheoffest_ : *default_instance_->targettacheoffest_;
}
inline ::NFFS::FSVector3* ParticleEvents_Particle::mutable_targettacheoffest() {
  set_has_targettacheoffest();
  if (targettacheoffest_ == NULL) targettacheoffest_ = new ::NFFS::FSVector3;
  return targettacheoffest_;
}
inline ::NFFS::FSVector3* ParticleEvents_Particle::release_targettacheoffest() {
  clear_has_targettacheoffest();
  ::NFFS::FSVector3* temp = targettacheoffest_;
  targettacheoffest_ = NULL;
  return temp;
}
inline void ParticleEvents_Particle::set_allocated_targettacheoffest(::NFFS::FSVector3* targettacheoffest) {
  delete targettacheoffest_;
  targettacheoffest_ = targettacheoffest;
  if (targettacheoffest) {
    set_has_targettacheoffest();
  } else {
    clear_has_targettacheoffest();
  }
}

// required int32 CastToSurface = 7;
inline bool ParticleEvents_Particle::has_casttosurface() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParticleEvents_Particle::set_has_casttosurface() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParticleEvents_Particle::clear_has_casttosurface() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParticleEvents_Particle::clear_casttosurface() {
  casttosurface_ = 0;
  clear_has_casttosurface();
}
inline ::google::protobuf::int32 ParticleEvents_Particle::casttosurface() const {
  return casttosurface_;
}
inline void ParticleEvents_Particle::set_casttosurface(::google::protobuf::int32 value) {
  set_has_casttosurface();
  casttosurface_ = value;
}

// required int32 BindTarget = 8;
inline bool ParticleEvents_Particle::has_bindtarget() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ParticleEvents_Particle::set_has_bindtarget() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ParticleEvents_Particle::clear_has_bindtarget() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ParticleEvents_Particle::clear_bindtarget() {
  bindtarget_ = 0;
  clear_has_bindtarget();
}
inline ::google::protobuf::int32 ParticleEvents_Particle::bindtarget() const {
  return bindtarget_;
}
inline void ParticleEvents_Particle::set_bindtarget(::google::protobuf::int32 value) {
  set_has_bindtarget();
  bindtarget_ = value;
}

// required string MethodCall = 9;
inline bool ParticleEvents_Particle::has_methodcall() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ParticleEvents_Particle::set_has_methodcall() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ParticleEvents_Particle::clear_has_methodcall() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ParticleEvents_Particle::clear_methodcall() {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    methodcall_->clear();
  }
  clear_has_methodcall();
}
inline const ::std::string& ParticleEvents_Particle::methodcall() const {
  return *methodcall_;
}
inline void ParticleEvents_Particle::set_methodcall(const ::std::string& value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void ParticleEvents_Particle::set_methodcall(const char* value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void ParticleEvents_Particle::set_methodcall(const char* value, size_t size) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParticleEvents_Particle::mutable_methodcall() {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  return methodcall_;
}
inline ::std::string* ParticleEvents_Particle::release_methodcall() {
  clear_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodcall_;
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParticleEvents_Particle::set_allocated_methodcall(::std::string* methodcall) {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete methodcall_;
  }
  if (methodcall) {
    set_has_methodcall();
    methodcall_ = methodcall;
  } else {
    clear_has_methodcall();
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodParam = 10;
inline bool ParticleEvents_Particle::has_methodparam() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ParticleEvents_Particle::set_has_methodparam() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ParticleEvents_Particle::clear_has_methodparam() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ParticleEvents_Particle::clear_methodparam() {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    methodparam_->clear();
  }
  clear_has_methodparam();
}
inline const ::std::string& ParticleEvents_Particle::methodparam() const {
  return *methodparam_;
}
inline void ParticleEvents_Particle::set_methodparam(const ::std::string& value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void ParticleEvents_Particle::set_methodparam(const char* value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void ParticleEvents_Particle::set_methodparam(const char* value, size_t size) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParticleEvents_Particle::mutable_methodparam() {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  return methodparam_;
}
inline ::std::string* ParticleEvents_Particle::release_methodparam() {
  clear_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodparam_;
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParticleEvents_Particle::set_allocated_methodparam(::std::string* methodparam) {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete methodparam_;
  }
  if (methodparam) {
    set_has_methodparam();
    methodparam_ = methodparam;
  } else {
    clear_has_methodparam();
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ParticleEvents

// repeated .NFFS.ParticleEvents.Particle xParticleList = 1;
inline int ParticleEvents::xparticlelist_size() const {
  return xparticlelist_.size();
}
inline void ParticleEvents::clear_xparticlelist() {
  xparticlelist_.Clear();
}
inline const ::NFFS::ParticleEvents_Particle& ParticleEvents::xparticlelist(int index) const {
  return xparticlelist_.Get(index);
}
inline ::NFFS::ParticleEvents_Particle* ParticleEvents::mutable_xparticlelist(int index) {
  return xparticlelist_.Mutable(index);
}
inline ::NFFS::ParticleEvents_Particle* ParticleEvents::add_xparticlelist() {
  return xparticlelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::ParticleEvents_Particle >&
ParticleEvents::xparticlelist() const {
  return xparticlelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::ParticleEvents_Particle >*
ParticleEvents::mutable_xparticlelist() {
  return &xparticlelist_;
}

// -------------------------------------------------------------------

// EnableEvents_Enable

// required float EventTime = 1;
inline bool EnableEvents_Enable::has_eventtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnableEvents_Enable::set_has_eventtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnableEvents_Enable::clear_has_eventtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnableEvents_Enable::clear_eventtime() {
  eventtime_ = 0;
  clear_has_eventtime();
}
inline float EnableEvents_Enable::eventtime() const {
  return eventtime_;
}
inline void EnableEvents_Enable::set_eventtime(float value) {
  set_has_eventtime();
  eventtime_ = value;
}

// required .NFFS.EnableEvents.EEETYPE EventType = 2;
inline bool EnableEvents_Enable::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnableEvents_Enable::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnableEvents_Enable::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnableEvents_Enable::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::NFFS::EnableEvents_EEETYPE EnableEvents_Enable::eventtype() const {
  return static_cast< ::NFFS::EnableEvents_EEETYPE >(eventtype_);
}
inline void EnableEvents_Enable::set_eventtype(::NFFS::EnableEvents_EEETYPE value) {
  assert(::NFFS::EnableEvents_EEETYPE_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// required string TargetName = 3;
inline bool EnableEvents_Enable::has_targetname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnableEvents_Enable::set_has_targetname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnableEvents_Enable::clear_has_targetname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnableEvents_Enable::clear_targetname() {
  if (targetname_ != &::google::protobuf::internal::kEmptyString) {
    targetname_->clear();
  }
  clear_has_targetname();
}
inline const ::std::string& EnableEvents_Enable::targetname() const {
  return *targetname_;
}
inline void EnableEvents_Enable::set_targetname(const ::std::string& value) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(value);
}
inline void EnableEvents_Enable::set_targetname(const char* value) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(value);
}
inline void EnableEvents_Enable::set_targetname(const char* value, size_t size) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnableEvents_Enable::mutable_targetname() {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  return targetname_;
}
inline ::std::string* EnableEvents_Enable::release_targetname() {
  clear_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetname_;
    targetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnableEvents_Enable::set_allocated_targetname(::std::string* targetname) {
  if (targetname_ != &::google::protobuf::internal::kEmptyString) {
    delete targetname_;
  }
  if (targetname) {
    set_has_targetname();
    targetname_ = targetname;
  } else {
    clear_has_targetname();
    targetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodCall = 4;
inline bool EnableEvents_Enable::has_methodcall() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnableEvents_Enable::set_has_methodcall() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnableEvents_Enable::clear_has_methodcall() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnableEvents_Enable::clear_methodcall() {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    methodcall_->clear();
  }
  clear_has_methodcall();
}
inline const ::std::string& EnableEvents_Enable::methodcall() const {
  return *methodcall_;
}
inline void EnableEvents_Enable::set_methodcall(const ::std::string& value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void EnableEvents_Enable::set_methodcall(const char* value) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(value);
}
inline void EnableEvents_Enable::set_methodcall(const char* value, size_t size) {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  methodcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnableEvents_Enable::mutable_methodcall() {
  set_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    methodcall_ = new ::std::string;
  }
  return methodcall_;
}
inline ::std::string* EnableEvents_Enable::release_methodcall() {
  clear_has_methodcall();
  if (methodcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodcall_;
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnableEvents_Enable::set_allocated_methodcall(::std::string* methodcall) {
  if (methodcall_ != &::google::protobuf::internal::kEmptyString) {
    delete methodcall_;
  }
  if (methodcall) {
    set_has_methodcall();
    methodcall_ = methodcall;
  } else {
    clear_has_methodcall();
    methodcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MethodParam = 5;
inline bool EnableEvents_Enable::has_methodparam() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnableEvents_Enable::set_has_methodparam() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnableEvents_Enable::clear_has_methodparam() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnableEvents_Enable::clear_methodparam() {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    methodparam_->clear();
  }
  clear_has_methodparam();
}
inline const ::std::string& EnableEvents_Enable::methodparam() const {
  return *methodparam_;
}
inline void EnableEvents_Enable::set_methodparam(const ::std::string& value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void EnableEvents_Enable::set_methodparam(const char* value) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(value);
}
inline void EnableEvents_Enable::set_methodparam(const char* value, size_t size) {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  methodparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnableEvents_Enable::mutable_methodparam() {
  set_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    methodparam_ = new ::std::string;
  }
  return methodparam_;
}
inline ::std::string* EnableEvents_Enable::release_methodparam() {
  clear_has_methodparam();
  if (methodparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = methodparam_;
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnableEvents_Enable::set_allocated_methodparam(::std::string* methodparam) {
  if (methodparam_ != &::google::protobuf::internal::kEmptyString) {
    delete methodparam_;
  }
  if (methodparam) {
    set_has_methodparam();
    methodparam_ = methodparam;
  } else {
    clear_has_methodparam();
    methodparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EnableEvents

// repeated .NFFS.EnableEvents.Enable xEnableList = 1;
inline int EnableEvents::xenablelist_size() const {
  return xenablelist_.size();
}
inline void EnableEvents::clear_xenablelist() {
  xenablelist_.Clear();
}
inline const ::NFFS::EnableEvents_Enable& EnableEvents::xenablelist(int index) const {
  return xenablelist_.Get(index);
}
inline ::NFFS::EnableEvents_Enable* EnableEvents::mutable_xenablelist(int index) {
  return xenablelist_.Mutable(index);
}
inline ::NFFS::EnableEvents_Enable* EnableEvents::add_xenablelist() {
  return xenablelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable >&
EnableEvents::xenablelist() const {
  return xenablelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::NFFS::EnableEvents_Enable >*
EnableEvents::mutable_xenablelist() {
  return &xenablelist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace NFFS

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::SuwayyahEvents_ESEType>() {
  return ::NFFS::SuwayyahEvents_ESEType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::BulletEvents_EBEType>() {
  return ::NFFS::BulletEvents_EBEType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::BulletEvents_EBE_BACKType>() {
  return ::NFFS::BulletEvents_EBE_BACKType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::AnimatorMoves_EAMType>() {
  return ::NFFS::AnimatorMoves_EAMType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::CameraControlEvents_ECEType>() {
  return ::NFFS::CameraControlEvents_ECEType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::ParticleEvents_EPERTYPE>() {
  return ::NFFS::ParticleEvents_EPERTYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFFS::EnableEvents_EEETYPE>() {
  return ::NFFS::EnableEvents_EEETYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NFFleetingDefine_2eproto__INCLUDED
